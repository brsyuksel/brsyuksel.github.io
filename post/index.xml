<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
      <title>Posts on barış yüksel </title>
      <generator uri="https://hugo.spf13.com">Hugo</generator>
    <link>http://brsyuksel.github.io/post/index.xml/</link>
    <language>tr_TR</language>
    
    
    <updated>Fri, 24 Oct 2014 03:19:43 EEST</updated>
    
    <item>
      <title>yeni blog</title>
      <link>http://brsyuksel.github.io/post/yeni-blog/</link>
      <pubDate>Fri, 24 Oct 2014 03:19:43 EEST</pubDate>
      
      <guid>http://brsyuksel.github.io/post/yeni-blog/</guid>
      <description>&lt;p&gt;öğrencilik hayatımın devam ediyor olmasının yanında getirdiği maddi nedenlerden ötürü blogumun barındığı &lt;a href=&#34;http://digitalocean.com&#34;&gt;do&lt;/a&gt; droplet&amp;rsquo;imi kapatmak zorunda kaldım. gün içerisinde hızlıca &lt;a href=&#34;http://gohugo.io&#34;&gt;hugo engine&lt;/a&gt; ile static bir blog oluşturdum ve &lt;a href=&#34;https://pages.github.io&#34;&gt;github pages&lt;/a&gt; ile yayına aldım. kısa süre içerisinde de eski yazıları buraya alacağım.&lt;/p&gt;

&lt;p&gt;go ile geliştirilmiş &lt;a href=&#34;http://gohugo.io&#34;&gt;hugo&lt;/a&gt; ile tanışmanızı öneririm. benim kendisini tercih etmemdeki en önemli etken, bir daha kullanacağımı düşünmediğim bağımlılıkları kurmak istemiyor olmam. hugo&amp;rsquo;nun &lt;a href=&#34;https://github.com/spf13/hugo/releases&#34;&gt;prebuilt version&lt;/a&gt;&amp;lsquo;larından size uygun olanı indirip kurulum &amp;amp; derleme yapmadan kullanmaya başlayabilirsiniz.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>mocha - js/cs test framework</title>
      <link>http://brsyuksel.github.io/post/mocha/</link>
      <pubDate>Mon, 01 Sep 2014 18:52:27 &#43;0200</pubDate>
      
      <guid>http://brsyuksel.github.io/post/mocha/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;http://visionmedia.github.io/mocha/&#34;&gt;mocha&lt;/a&gt;, node.js ve aynı zamanda browser&amp;rsquo;larda çalışabilen bir javascript test framework&amp;rsquo;ü. bir çok test interface&amp;rsquo;i, assertion library&amp;rsquo;si desteği, çalışma zamanı seçenekleri ile gerçekten yeterince olgun ve kolaylık sağlayan bir framework. ayrıca coffeescript desteği mevcut olması benim için tercih sebeplerinden bir tanesi oldu.&lt;/p&gt;

&lt;p&gt;ben bu yazıda mocha&amp;rsquo;yı node.js üzerinde bdd interface&amp;rsquo;i ve node.js&amp;rsquo;in default assert kütüphanesi ile nasıl kullanabileceğinizden bahsedeceğim. uygulama geliştirirken test yazmanız için yeterli olacaktır ancak &lt;a href=&#34;http://visionmedia.github.io/mocha/#interfaces&#34;&gt;diğer interface&lt;/a&gt;&amp;lsquo;ler ve &lt;a href=&#34;http://visionmedia.github.io/mocha/#assertions&#34;&gt;assertion kütüphanelerini&lt;/a&gt; kullanmak dilerseniz onlar da gayet kolay.&lt;/p&gt;

&lt;h1 id=&#34;toc_0&#34;&gt;node.js assert kütüphanesi&lt;/h1&gt;

&lt;p&gt;mocha&amp;rsquo;yı kullanmadan önce node.js&amp;rsquo;in assert kütüphanesini tanımak önemli. assert kütüphanesinde detaylandırılacak pek bir nokta yok bu nedenle kütüphaneyi method&amp;rsquo;larıyla ve küçük örneklerle hızlıca tanıtacağım.&lt;/p&gt;

&lt;p&gt;assert kütüphanesi method&amp;rsquo;ları, parametre olarak verilen değer(ler) için karşılaştırma yapar. belirli durumlar için karşılaştırma method&amp;rsquo;ları mevcut olup şartın sağlanmaması durumunda &lt;strong&gt;AssertionError&lt;/strong&gt; throw ederler.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;assert.ok(value, [message]); // assert(value, [message])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;bu method bir değerin undefined/null olup olmadığını test eder. yani yapılan işlem şudur: &lt;code&gt;!!value == true&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;assert.ifError(value)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;bu method ise &lt;strong&gt;assert.ok&lt;/strong&gt;&amp;lsquo;un olumsuzu olarak kullanılabilir. false değerler için sağlanırken, true değerler için exception throw edilir.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;assert.equal(a, b, [message])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;bu method ile a ve b değerlerinin eşitliği karşılaştırılır, &amp;ldquo;a == b&amp;rdquo;. olumsuzu için, yani &amp;ldquo;a != b&amp;rdquo; için &lt;code&gt;assert.notEqual&lt;/code&gt; benzer şekilde kullanılır.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;assert.deepEqual(a, b, [message])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;verilen değerlere çeşitli karşılaştırma yapar. object olmayanlar için &amp;ldquo;==&amp;rdquo; karşılaştırması, date objectler için getTime karşılaştırması, objectler içinse size, key, lenght gibi çeşitli karşılaştırmalar yapar. olumsuz koşul için &lt;code&gt;assert.notDeepEqual&lt;/code&gt; kullanılır.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;assert.strictEqual(a, b, [message])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;değerler arasında strict karşılaştırma yapar, &amp;ldquo;a === b&amp;rdquo;. olumsuzu için &lt;code&gt;assert.notStrictEqual&lt;/code&gt; kullanılır.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;assert.throws(block, [error], [message])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;bu method ile verilen block&amp;rsquo;un error throw etme durumu kontrol edilir. error parametresi ile regexp bir value olarak verildiğinde exception mesajı ile eşleşmesi kontrol edilirken, function olarak da verilip kullanıcı tanımlı işlem gerçekleştirilebilir. yine exception throw etmeyen durumlar için &lt;code&gt;assert.doesNotThrow(block, [message])&lt;/code&gt; kullanılabilir.&lt;/p&gt;

&lt;h1 id=&#34;toc_1&#34;&gt;mocha&lt;/h1&gt;

&lt;p&gt;mocha&amp;rsquo;nın npm ile kurulumunu şu şekilde: &lt;code&gt;npm install -g mocha&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;mocha ile test yazmaya başlamadan önce yapmanız gereken, &lt;strong&gt;proje dizini altında test adında bir klasör oluşturmak ve test kodlarını içeren dosyaları bu klasör altında bulundurmak.&lt;/strong&gt; mocha, çalıştırıldığı zaman bu klasörü arıyor ve burdaki test kodlarını içeren dosyaları yürütüyor.&lt;/p&gt;

&lt;p&gt;bdd interface&amp;rsquo;i ile senaryo üzerine test kodu yazılır. mocha&amp;rsquo;nın bdd interface&amp;rsquo;i için api&amp;rsquo;lerinden ilk karşılaşacağımız &lt;strong&gt;describe&lt;/strong&gt;. bu method ile test case&amp;rsquo;lerinizi barındıran bir &lt;em&gt;suite&lt;/em&gt; oluşturuyorsunuz. gerektiği taktirde nested olarak da kullanabiliyorsunuz. daha sonra da bu suite altında &lt;strong&gt;it&lt;/strong&gt; method&amp;rsquo;unu kullanarak senaryonuza yönelik testlerinizi yazıyorsunuz.&lt;/p&gt;

&lt;p&gt;genel kullanıma bir örnek:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-coffeescript&#34;&gt;describe &amp;quot;tests&amp;quot;, -&amp;gt;
  it &amp;quot;should return 0 when the value is not present&amp;quot;, -&amp;gt;
    # ...
  it &amp;quot;should return positive when the value is negative&amp;quot;, -&amp;gt;
    # ...
  describe &amp;quot;nested tests&amp;quot;, -&amp;gt;
    it &amp;quot;should ...&amp;quot;, -&amp;gt;
      # ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;bu örnek ile &lt;strong&gt;sync&lt;/strong&gt; çalışan kodlarınız için test-case&amp;rsquo;ler yazmanız mümkün. &lt;strong&gt;async&lt;/strong&gt; için ise, test-case&amp;rsquo;i tanımlarken &lt;strong&gt;it&lt;/strong&gt; fonksiyonunda tanımladığımız callback fonksiyonu, &lt;strong&gt;bir&lt;/strong&gt; parametre alacak şekilde tanımlıyoruz. mocha, bu durumda fonksiyonu &lt;strong&gt;bir callback parametresi&lt;/strong&gt; ile çağırıyor ve test-case&amp;rsquo;in sonuçlanması için kendisi tarafından verilen bu &lt;strong&gt;callback&amp;rsquo;in çağrılmasını&lt;/strong&gt; bekliyor. eğer bu callback bir parametre ile çağrılmıyorsa sonuç başarılı, bir error parametresi ile çağrılıyorsa sonuç başarısız kabul ediliyor. async fonksiyonlarınızda callback parametresi ya da promise kullanarak bu callback&amp;rsquo;in çağrılmasını sağlayabilirsiniz.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-coffeescript&#34;&gt;f = (x) -&amp;gt; unless x then 0 else x

describe &amp;quot;sync test&amp;quot;, -&amp;gt;
  it &amp;quot;should return 0 when the value is not present&amp;quot;, -&amp;gt;
    assert.equal f(), 0

describe &amp;quot;async test&amp;quot;, -&amp;gt;
  it &amp;quot;should do nothing when the file is exists&amp;quot;, (done) -&amp;gt;
    fs = require &#39;fs&#39;
    fs.exists &#39;/etc/passwd&#39;, (e) -&amp;gt;
      unless e then done new Error else done()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;bdd interface&amp;rsquo;inde test-case&amp;rsquo;lerin yürütülme öncesi ve sonrası için belirli rutinleri gerçekleştirebilmeniz adına hook&amp;rsquo;lar mevcut. &lt;strong&gt;before&lt;/strong&gt; hook&amp;rsquo;u ile herhangi bir test-case yürütülmeden önce, &lt;strong&gt;after&lt;/strong&gt; ile suite altındaki tüm test-case&amp;rsquo;ler bittikten sonra çalıştırılacak callback&amp;rsquo;ler tanımlayabilirsiniz. benzer şekilde &lt;strong&gt;beforeEach&lt;/strong&gt; ile suite altındaki her test-case yürütülmeden önce ve &lt;strong&gt;afterEach&lt;/strong&gt; ile de suite altındaki her test-case yürütüldükten sonra çağrılacak callback&amp;rsquo;ler tanımlayabilirsiniz. &lt;em&gt;diğer interface&amp;rsquo;ler için de belirli hook&amp;rsquo;lar var ve bunlar da yine bdd hook&amp;rsquo;ları gibi gayet kolay.&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-coffeescript&#34;&gt;describe &amp;quot;before-after&amp;quot;, -&amp;gt;
  before -&amp;gt; console.log &amp;quot;hic test yurutulmedi...&amp;quot;
  after -&amp;gt; console.log &amp;quot;butun testler bitti...&amp;quot;
  beforeEach -&amp;gt; console.log &amp;quot;bir test yurutulecek...&amp;quot;
  afterEach -&amp;gt; console.log &amp;quot;bir test bitti...&amp;quot;
  # ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;bundan sonrası suite&amp;rsquo;ler ve test-case&amp;rsquo;ler için kullanışlı methodlar.&lt;/p&gt;

&lt;p&gt;bir çok test arasında kaybolmaya başladığınızda &lt;code&gt;describle.only&lt;/code&gt; ve &lt;code&gt;it.only&lt;/code&gt; kullanarak &lt;strong&gt;sadece bir suite ya da test-case&lt;/strong&gt;&amp;lsquo;in çalışmasını sağlayabilirsiniz. test sonuçları çıktısında sadece ilgili testlerin sonuçlarını göreceksiniz.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;describe.skip&lt;/code&gt; ve &lt;code&gt;it.skip&lt;/code&gt; ile ilgili &lt;strong&gt;suite/test-case&amp;rsquo;in çalışmasını engelleyebilirsiniz&lt;/strong&gt;. bu durumda ilgili test, pending olarak sonuçlanacaktır.&lt;/p&gt;

&lt;p&gt;bir test-case&amp;rsquo;i &lt;strong&gt;pending&lt;/strong&gt; olarak tanımlamak istiyorsanız, it fonksiyonuna callback tanımlamayarak sağlayabilirsiniz.&lt;/p&gt;

&lt;p&gt;ve testleri çalıştırma işlemi. javascript ile yazdığınız testleri sonuçlandırmak istiyorsanız:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;mocha
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;coffeescript için ise bir parametreye ihtiyaç duyuyoruz:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;mocha --compilers coffee:coffee-script/register
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;test dosyalarınızdaki değişikliğin mocha tarafından takip edilerek değişiklik sonrası otomatik olarak çalıştırılması için:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;mocha --watch
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;son olarak her seferinde bu parametreleri tekrar tekrar yazmak istemiyorsanız, &lt;strong&gt;test&lt;/strong&gt; klasörü altında &lt;strong&gt;mocha.opts&lt;/strong&gt; adında bir dosya oluşturun ve şu şekilde düzenleyin:&lt;/p&gt;

&lt;p&gt;&amp;ndash;compilers coffee:coffee-script/register
  -R spec
  &amp;ndash;watch&lt;/p&gt;

&lt;p&gt;bu dosyayı düzenledikten sonra sadece &lt;code&gt;mocha&lt;/code&gt; komutunu vermek yeterli olacak.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://visionmedia.github.io/mocha/&#34;&gt;mocha&lt;/a&gt;&amp;lsquo;nın sitesinden diğer interface&amp;rsquo;lere, reporter&amp;rsquo;lara, browser support&amp;rsquo;a ve diğer yeteneklerine bakmayı ihmal etmeyin.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>lxc</title>
      <link>http://brsyuksel.github.io/post/lxc/</link>
      <pubDate>Mon, 01 Sep 2014 18:50:33 &#43;0200</pubDate>
      
      <guid>http://brsyuksel.github.io/post/lxc/</guid>
      <description>

&lt;p&gt;lxc, açılımıyla &lt;em&gt;linux containers&lt;/em&gt;, linux sistemlerde kullanabileceğiniz bir başka virtualization uygulaması/method&amp;rsquo;udur. en öne çıkan yanı tam sanallaştırma yerine, bir init process&amp;rsquo;inin etrafında kurulu belirli process&amp;rsquo;lerin farklı bir kök dizini altında çalıştırılarak sanallaştırmanın gerçekleştirilmesidir. bunun yanında lxc, kernel&amp;rsquo;in cgroups, namespace, bridging, virtual lan gibi özelliklerden yararlandığı için chroot ile full-vm arasında bir noktada denilebilir. full-vm&amp;rsquo;ler gibi resource management uygulanabilir, device&amp;rsquo;lar paylaşılabilir. full-vm&amp;rsquo;lere oranla kurmak, yönetmek, yürütmek oldukça daha hızlı ve basittir.&lt;/p&gt;

&lt;h1 id=&#34;toc_0&#34;&gt;kernel ve kurulum&lt;/h1&gt;

&lt;p&gt;lxc&amp;rsquo;nin yeteneklerini tam anlamıyla kullanabilmeniz için kernel&amp;rsquo;in belirli bir şekilde derlenmiş olması gerekiyor. kernel derleme aşamasına gelmeden önce paket yöneticinizden lxc&amp;rsquo;yi kurun.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;slackware 14.1&lt;/strong&gt; tarafında, güncel repolarda bulunan lxc&amp;rsquo;nin sürümü 0.9.0, bu sürüm belirli özellikleri barındırmıyor olduğu gibi slackware template&amp;rsquo;i de içermiyor, bu nedenle slackbuilds ekibinin düzenlediği sürümü kurun. bu sürüm ise 1.0.3 olup slackware template&amp;rsquo;i içeriyor. yalnız slackware template&amp;rsquo;nin düzgün çalışabilmesi için patch&amp;rsquo;lenmiş bir slackpkg&amp;rsquo;e ihtiyaç duyacaksınız ( slackpkg&amp;rsquo;in kodlarını inceleyince fark edersiniz ), bu da yine aynı ekip tarafından patch&amp;rsquo;lenmiş. &lt;a href=&#34;http://ponce.cc/slackware/testing/lxc/&#34;&gt;lxc-1.0.3 slackbuild&lt;/a&gt;, &lt;a href=&#34;http://ponce.cc/slackware/utilities/&#34;&gt;patched slackpkg&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;kurulumu gerçekleştirdikten sonra şu komut ile kernel durumunuzu kontrol edebilirsiniz: &lt;code&gt;lxc-checkconfig&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;çıktıda &amp;ldquo;missing&amp;rdquo; şeklinde bir sonuç alırsanız, bu desteği sağlayacak şekilde yeniden kernel derlemeniz gerekiyor. kernel&amp;rsquo;i lxc için uygun olacak şekilde nasıl derleyeceğiniz hakkında bilgi man sayfasında mevcut: &lt;code&gt;man lxc&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;kernel derleme işleminde configuration&amp;rsquo;ı tamamladıktan sonra &lt;code&gt;CONFIG=.config lxc-checkconfig&lt;/code&gt; komutuyla yeni configuration&amp;rsquo;ın eksik olup olmadığını kontrol ederek derleme işleminize geçebilirsiniz.&lt;/p&gt;

&lt;h1 id=&#34;toc_1&#34;&gt;container &lt;em&gt;(vm)&lt;/em&gt; oluşturma&lt;/h1&gt;

&lt;p&gt;lxc ile container oluşturulurken, &lt;em&gt;(slackware için &lt;code&gt;/usr/share/lxc/templates/&lt;/code&gt; klasörü altında yer alan)&lt;/em&gt; template scriptleri kullanılıyor. bu template scriptleri, dağıtıma göre &lt;strong&gt;lxc-DISTRONAME&lt;/strong&gt; adını taşıyan bash scriptler ve container oluşturulma anında genel olarak, dağıtımınızla benzer kök dizin hiyerarşisini oluşturuyor, container&amp;rsquo;ın çalışması için gerekli paketleri indirip kuruyor, lxc configuration&amp;rsquo;ını sağlanıyor. &lt;strong&gt;burda dikkat etmeniz gereken, host olarak kullandığınız dağıtımla container olarak kullanacağınız dağıtımın aynı olması.&lt;/strong&gt; &lt;em&gt;incelediğim kadarıyla, template&amp;rsquo;lerin içerisinde host dağıtımdan bağımsız şekilde çalışabilecek bir template yok. aslında yapılabilir bir olay ancak lxc&amp;rsquo;i vakitten tasarruf etmek için kullandığımızı unutmamak lazım :)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;hızlıca şu komutla bir container oluşturabilirsiniz:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo lxc-create -t slackware -n deneme
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;bu komut sonrası bahsettiğim işlemler yürütülecek ve daha sonra container için gerekli paketler dağıtımın paket yöneticisi tarafından, container&amp;rsquo;ın kök dizini altına yüklecek ve &lt;strong&gt;deneme&lt;/strong&gt; adında ilk container&amp;rsquo;ımız hazırlanmış olacak. container oluşturma işlemi fazla zamanınızı almayacaktır.&lt;/p&gt;

&lt;h1 id=&#34;toc_2&#34;&gt;yürütme, durdurma, console&lt;/h1&gt;

&lt;p&gt;oluşturduğumuz container&amp;rsquo;ı yürütmek için:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo lxc-start -n deneme -d
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;ps aux&lt;/code&gt; çıktısına baktığınızda yeni bir &lt;strong&gt;init/systemd&lt;/strong&gt; process&amp;rsquo;i görüyor olmalısınız. bahsettiğim gibi yeni bir init process&amp;rsquo;i farklı bir kök dizin altında çalışmaya başladı. şimdi bu container&amp;rsquo;ın &lt;strong&gt;console&lt;/strong&gt;&amp;lsquo;una bağlanalım:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo lxc-console -n deneme
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;login uygulaması ile karşılaşacaksınız. genel olarak &lt;strong&gt;kullanıcı: root, şifre: root&lt;/strong&gt;. bu noktadan sonra container&amp;rsquo;ınızı dilediğiniz gibi kullanabilirsiniz. &lt;strong&gt;bu console&amp;rsquo;dan çıkmak için ctrl+a kombinasyonundan sonra q tuşuna basın.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;container&amp;rsquo;ı &lt;strong&gt;durdurmak için&lt;/strong&gt; container console&amp;rsquo;da &lt;code&gt;poweroff&lt;/code&gt; komutunu verebilirsiniz, ya da host terminal&amp;rsquo;inden:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo lxc-stop -n deneme
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;komutu ile container&amp;rsquo;ı durdurabilirsiniz. bazı durumlarda bu şekilde durdurmak başarısız olabiliyor, bu nedenle &lt;strong&gt;-k&lt;/strong&gt; parametresi ekleyerek container process&amp;rsquo;lerinin &lt;strong&gt;kill&lt;/strong&gt; edilerek durdurulmasını sağlayabilirsiniz.&lt;/p&gt;

&lt;h1 id=&#34;toc_3&#34;&gt;freeze, unfreeze&lt;/h1&gt;

&lt;p&gt;container&amp;rsquo;ları kullanmadığınız, işlem yapmadığınız durumlarda &lt;strong&gt;freeze&lt;/strong&gt; ederek &lt;em&gt;( SIGSTOP gibi )&lt;/em&gt;, host tarafında işlem yükünü azaltabilirsiniz.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo lxc-freeze -n deneme
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;freeze edilmiş bir container&amp;rsquo;ı tekrar yürütmek için &lt;em&gt;( SIGCONT )&lt;/em&gt;,&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo lxc-unfreeze -n deneme
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;toc_4&#34;&gt;dosya paylaşımı&lt;/h1&gt;

&lt;p&gt;lxc&amp;rsquo;de dosya paylaşımı diğer vm method&amp;rsquo;larına göre çok daha kolay. eğer container&amp;rsquo;ınız için logical volume kullanmıyorsanız, lxc rootfs&amp;rsquo;ine host üzerinden erişiminiz mümkün. &lt;strong&gt;genel lxc configuration&amp;rsquo;ı için&lt;/strong&gt;, bu yol şu şekilde: &lt;code&gt;/var/lib/lxc/deneme/rootfs/&lt;/code&gt; . bu dizin altına girdiğinizde kök dizin yapısıyla karşılaşacaksınız. dosya paylaşımlarını bu şekilde gerçekleştirebilirsiniz. bu klasöre kolayca erişmek istediğiniz zaman şu komut işinizi görecektir:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;su -
cd /proc/$(lxc-info -n deneme -p -H)/root
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;daha güzel bir yöntem ise container configuration&amp;rsquo;ından yararlanmak. lxc ile host tarafındaki bir klasörün container tarafından &lt;strong&gt;bind-mount&lt;/strong&gt; edilmesini sağlayabiliyoruz. bunu ister &lt;strong&gt;lxc container config&lt;/strong&gt; dosyasından, isterseniz de &lt;strong&gt;container&amp;rsquo;ın fstab dosyası&lt;/strong&gt; aracılığıyla gerçekleştirebilirsiniz.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;container fstab&lt;/strong&gt; dosyası &lt;code&gt;/var/lib/lxc/deneme/rootfs/etc/fstab&lt;/code&gt; için örnek olarak şu girdiyi ekleyin:&lt;/p&gt;

&lt;p&gt;/host/uzerindeki/klasor container/uzerinde/yol none bind,create=dir 0 0&lt;/p&gt;

&lt;p&gt;ya da &lt;strong&gt;lxc container config&lt;/strong&gt; dosyası &lt;code&gt;/var/lib/lxc/deneme/config&lt;/code&gt; için şöyle bir ekleme yapabilirsiniz:&lt;/p&gt;

&lt;p&gt;lxc.mount.entry = /host/uzerindeki/klasor container/uzerinde/yol none bind.create=dir 0.0&lt;/p&gt;

&lt;p&gt;bu iki işlemden birini gerçekleştirdikten sonra container&amp;rsquo;ınızı &lt;strong&gt;reboot&lt;/strong&gt; edin, belirlediğiniz klasör container üzerinde mount edilmiş olacaktır.&lt;/p&gt;

&lt;h1 id=&#34;toc_5&#34;&gt;network&lt;/h1&gt;

&lt;p&gt;öncelikle sisteminizde &lt;strong&gt;bridge-utils, dnsmasq, iptables&lt;/strong&gt; paketleri kurulu olmalı. paket yöneticiniz aracılığıyla bu paketleri kurun.&lt;/p&gt;

&lt;p&gt;ilk aşamada &lt;strong&gt;container config dosyasında&lt;/strong&gt; bir kaç ekleme yapmamız gerekiyor.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;/var/lib/lxc/deneme/config&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;lxc.network.type = veth
  lxc.network.hwaddr = 00:16:3e:3a:f1:c1
  lxc.network.flags = up
  lxc.network.link = br0
  lxc.network.name = eth0&lt;/p&gt;

&lt;p&gt;bu configuration ile &lt;strong&gt;type&lt;/strong&gt; satırında lxc&amp;rsquo;ye veth tunnel device kullanacağımızı bildiriyoruz. &lt;strong&gt;hwaddr&lt;/strong&gt; satırı container&amp;rsquo; için oluşturulacak device&amp;rsquo;ın mac adresi. &lt;strong&gt;flags&lt;/strong&gt; satırında device&amp;rsquo;ı up ediyoruz. &lt;strong&gt;link&lt;/strong&gt; satırında ise host tarafında var olan device&amp;rsquo;a tunnel yapıyoruz ve &lt;strong&gt;name&lt;/strong&gt; satırında container&amp;rsquo;ın virtual device&amp;rsquo;ının ismini belirliyoruz.&lt;/p&gt;

&lt;p&gt;sıradaki işlem bir &lt;strong&gt;bridge device oluşturma.&lt;/strong&gt; bunun için şu komutları uygulayabilirsiniz.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;su -
brctl addbr br0
brctl setfd br0 0
ifconfig br0 192.168.100.1 netmask 255.255.255.0 promisc up
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;bu aşamada &lt;strong&gt;br0&lt;/strong&gt; bridge-device oluşturulmuş ve &lt;strong&gt;192.168.100.1 ip adresi ile&lt;/strong&gt; up edilmiş olacaktır. kernel variable&amp;rsquo;larında &lt;strong&gt;ip_forward&lt;/strong&gt; ve &lt;strong&gt;br0 için proxy_arp&lt;/strong&gt;&amp;lsquo;ı açmamız gerekiyor, şu şekilde devam edin:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;echo 1 &amp;gt; /proc/sys/net/ipv4/ip_forward
echo 1 &amp;gt; /proc/sys/net/ipv4/conf/br0/proxy_arp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ve daha sonra, host sistemde &lt;strong&gt;nat tablosuna bir trafik yönlendirmesi kayıdı&lt;/strong&gt; eklememiz gerekiyor &lt;em&gt;(ben bu örnekte internet erişimim wlan0 device&amp;rsquo;ından gerçekleştiği için out device olarak wlan0 kullandım, siz durumuna göre gerekli değişikliği yapmalısınız)&lt;/em&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;iptables -t nat -A POSTROUTING -o wlan0 -j MASQUERADE
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;internet erişimi olan bir container&amp;rsquo;a sahip olmamız için son aşama, bu container&amp;rsquo;lara &lt;strong&gt;ip adresi atayacak bir dhcp server&lt;/strong&gt;&amp;lsquo;a ihtiyacımız var, bunun için &lt;strong&gt;dnsmasq&lt;/strong&gt;&amp;lsquo;ı kullanıyoruz.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;dnsmasq&amp;rsquo;ın global configuration dosyasını&lt;/strong&gt; &lt;code&gt;/etc/dnsmasq.conf&lt;/code&gt; açın ve şu satırı ekleyin:&lt;/p&gt;

&lt;p&gt;conf-dir=/etc/dnsmasq.d&lt;/p&gt;

&lt;p&gt;şimdi &lt;code&gt;/etc/dnsmasq.d&lt;/code&gt; klasörü altına gidin ( yoksa oluşturun ) ve &lt;strong&gt;br0.conf&lt;/strong&gt; adında bir dosya oluşturarak &lt;em&gt;(dosya ismi önemli değil)&lt;/em&gt; şu eklemeleri yapın:&lt;/p&gt;

&lt;p&gt;interface=br0
  dhcp-range=192.168.100.2,192.168.100.254,72h&lt;/p&gt;

&lt;p&gt;kaydettikten sonra &lt;strong&gt;dnsmasq&amp;rsquo;ı başlatın&lt;/strong&gt;. dnsmasq, container device&amp;rsquo;larımıza 192.168.100.2-192.168.100.254 arasında bir ip atayacak.&lt;/p&gt;

&lt;p&gt;şimdi: &lt;code&gt;sudo lxc-start -n deneme -d&lt;/code&gt; :)&lt;/p&gt;

&lt;p&gt;lxc için veth dışında farklı network yöntemleri mevcut, bunun için man sayfasından yararlanabilirsiniz.&lt;/p&gt;

&lt;h1 id=&#34;toc_6&#34;&gt;daha fazlası&lt;/h1&gt;

&lt;p&gt;lxc maintainer&amp;rsquo;larından stephane graber&amp;rsquo;in blogunda &lt;a href=&#34;https://www.stgraber.org/2013/12/20/lxc-1-0-blog-post-series/&#34;&gt;güzel bir yazı dizisi&lt;/a&gt; var, okumanızı öneririm. autostart, network, storage, arch, hooks, security, namespaces, unprivilaged containers ve scripting yazılarına kesinlikle bakın derim.&lt;/p&gt;

&lt;h1 id=&#34;toc_7&#34;&gt;öneri&lt;/h1&gt;

&lt;p&gt;ilk olarak, daha önce virtualization işlemleri için libvirt ile tanışmış arkadaşlar için söylüyorum, libvirt güncel olarak lxc&amp;rsquo;i desteklemektedir. libvirt&amp;rsquo;in ilgili paketlerini kurarak libvirt ve virsh aracılığıyla container&amp;rsquo;larınızı yönetebilirsiniz.&lt;/p&gt;

&lt;p&gt;lxc&amp;rsquo;i daha basit ve hızlı bir şekilde kullanabilmek, container&amp;rsquo;ları yönetmek (ve daha fazlasını) istiyorsanız son derece popüler olan &lt;a href=&#34;http://docker.io&#34;&gt;docker.io&amp;rsquo;ya&lt;/a&gt; kesinlikle bakmalısınız. sitesinde hızlıca erişebileceğiniz bir &amp;ldquo;try it&amp;rdquo; online uygulaması mevcut, docker&amp;rsquo;ın yeteneklerini keşfetmeniz için yeterli olacaktır. bir çok dağıtım ve küçük linux vm&amp;rsquo;leri üzerinde çalışmak koşuluyla mac os ve windows platformları için kurulum guide&amp;rsquo;ları mevcut.&lt;/p&gt;

&lt;p&gt;full-vm aracılığıyla docker ve dolayısıyla lxc&amp;rsquo;i kullanabileceğiniz başka bir platform &lt;a href=&#34;https://coreos.com/&#34;&gt;coreos linux&lt;/a&gt;. kendisi küçük bir dağıtım olup distributed sistemlerde kolaylıkla yapılandırabileceğiniz araçlarla geliyor. incelemekte fayda var.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>javascript&#39;te property kavramları ve oop</title>
      <link>http://brsyuksel.github.io/post/js-oop/</link>
      <pubDate>Mon, 01 Sep 2014 18:46:47 &#43;0200</pubDate>
      
      <guid>http://brsyuksel.github.io/post/js-oop/</guid>
      <description>

&lt;p&gt;bir back-end developer olarak genel anlamda javascript&amp;rsquo;i uygulamaların arayüzünde fonksiyonelliğini sağlayacak kadar kullandım. bir çok back-end developer arkadaş da benimle aynı konumdadır diye düşünüyorum. ancak javascript&amp;rsquo;i server-side&amp;rsquo;da kullanmaya başladığınız zaman iş değişiyor ve browser üzerinde yeterli gelen bilginize başvurduğunuzda durum keyifsiz bir hal almaya başlıyor. dilin esnekliğini, base method&amp;rsquo;larını, yardımcı fonksiyonlarını bilmeden istenildiği kadar düzenli bir kod yazılsa da ( örneğin biz coffeescript&amp;rsquo;ten yararlanıyoruz ) başarılı olabileceğini düşünmüyorum. bu nedenle javascript&amp;rsquo;te belirli kavramları öğrenip burda paylaşmak istedim. bu dökümanda değişken türleri, dil yapısı, döngüler vb. gibi temel konular yerine özellikle object-oriented programming&amp;rsquo;de başvurabileceğiniz bazı kavramlarla karşılaşacaksınız.&lt;/p&gt;

&lt;h1 id=&#34;toc_0&#34;&gt;objects&lt;/h1&gt;

&lt;p&gt;object veri türü javascript&amp;rsquo;in en temel veri türlerinden birisi. basitçe &lt;code&gt;{}&lt;/code&gt; kullanarak oluşturduğumuz object türünü mdn ( mozilla developer network ) &lt;strong&gt;&amp;ldquo;property çantası&amp;rdquo;&lt;/strong&gt; adıyla güzel bir tanıma kavuşturmuş. burda object veri türünün tanımı yerine bu yazıda ihtiyacımız olan bir özelliği üzerinde duracağım.&lt;/p&gt;

&lt;p&gt;javascript&amp;rsquo;te diğer türlerden ziyade object&amp;rsquo;ler referance&amp;rsquo;larıyla işlenir. cümlelerle ifade etmektense basit bir örnek daha yararlı olacak:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var x = {}; // bos bir object
var y = x; // y, x&#39;in bir kopyasi degil, bir referance
x.a = 1;
console.log(y.a); // 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;yukarıdaki örnekte görüldüğü üzere y değişkeni x&amp;rsquo;i referans alır ve x&amp;rsquo;e eklenen her property y tarafında da erişilebilirdir.&lt;/p&gt;

&lt;p&gt;kavramların anlaşılabilir olması açısından javascript&amp;rsquo;te object oluşturma yöntemlerine de bakalım. ilki az önce de bahsettiğimiz gibi &lt;code&gt;{}&lt;/code&gt; deyimi yardımıyla:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var o = {
  n: 1,
  b: true,
  s: &amp;quot;value&amp;quot;,
  f: function(){},
  z: null
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ikincisi &lt;strong&gt;Object&lt;/strong&gt; class&amp;rsquo;ının &lt;strong&gt;create&lt;/strong&gt; methodu kullanılarak:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var o = Object.create({n:1, b:true});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Object.create method&amp;rsquo;unun asıl kullanımı şu şekilde ancak bu yazı sonuna kalsın: &lt;strong&gt;Object.create(prototype &lt;em&gt;[, properties]&lt;/em&gt;)&lt;/strong&gt;
hızlıca bu tanım doğrultusunda doğru bir kullanım aslında şu şekilde olmalıydı:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var o = Object.create(Object.prototype, {n:{value:1}, b:{value:true}});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Son object oluşturma yöntemi ise &lt;strong&gt;constructor function&lt;/strong&gt; tanımlayıp instance edinerek:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function anO(n){
  this.s = &amp;quot;value&amp;quot;;
  this.n = n; 
}

var o = new anO(1);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_1&#34;&gt;prototype&lt;/h2&gt;

&lt;p&gt;javascript&amp;rsquo;te object-oriented programming dökümanlarına baktığınız zaman &lt;strong&gt;prototype&lt;/strong&gt; kavramı ile karşılaşmanız kaçınılmazdır. prototype, oluşturduğunuz instance&amp;rsquo;ların miras alacağı property&amp;rsquo;leri barındıran bir object. &lt;code&gt;new&lt;/code&gt; &lt;strong&gt;keyword&lt;/strong&gt;&amp;lsquo;ü kullanarak oluşturduğunuz instance, &lt;strong&gt;class&amp;rsquo;ının prototype object&amp;rsquo;indeki tanımlı property&amp;rsquo;leri miras alarak&lt;/strong&gt; oluşturulur. basit bir örnek vermek gerekirse &lt;code&gt;var a = new Array(1,2,3);&lt;/code&gt; şeklinde oluşturduğunuz bir &lt;code&gt;a&lt;/code&gt; değişkeni, &lt;strong&gt;Array.prototype&lt;/strong&gt; object&amp;rsquo;inden &lt;strong&gt;push&lt;/strong&gt; methodunu miras alır.&lt;/p&gt;

&lt;p&gt;az önceki &lt;strong&gt;Object.create&lt;/strong&gt; method&amp;rsquo;unun kullanımını şimdi fark etmiş olmalısınız, &lt;strong&gt;ilk parametre miras alınacak prototype, ikinci parametre ise instance&amp;rsquo;ın kendi property&amp;rsquo;leri&lt;/strong&gt; şeklinde. biz ilk kullanımda aslında kendisine &lt;code&gt;{n:1, b:true}&lt;/code&gt; şeklinde tanımlı bir &lt;strong&gt;prototype&lt;/strong&gt; vermiştik ve &lt;code&gt;o&lt;/code&gt; değişkeni bu prototype&amp;rsquo;dan property&amp;rsquo;leri miras almıştı.&lt;/p&gt;

&lt;p&gt;anlaşıldığı gibi, class-based dillere nazaran prototype-based bir dil olan javascript&amp;rsquo;te bir class tanımlamak istediğinizde instance tarafından miras alınacak property&amp;rsquo;leri prototype&amp;rsquo;ına tanımlayacaksınız. bir örnek:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function Ornek(a,b){
  this.a = a || 0;
  this.b = b || 0;
}

Ornek.prototype.topla = function(){ return this.a+this.b; };

var o = new Ornek(1,2);
console.log( o.topla() );
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_2&#34;&gt;property&lt;/h2&gt;

&lt;p&gt;property&amp;rsquo;ler object&amp;rsquo;lerde key-value olarak taşınan değerler demiştik. bu genel başlık altında property&amp;rsquo;lerin türleri ve özelliklerini inceleyeceğiz.&lt;/p&gt;

&lt;p&gt;ilk olarak javascript object&amp;rsquo;lerinde &lt;strong&gt;&amp;ldquo;öz nitelik&amp;rdquo; (own-property)&lt;/strong&gt; kavramına değinelim. adında da anlaşılabileceği gibi, miras alınan property&amp;rsquo;ler ile initial değer alarak tanımlanmış property&amp;rsquo;leri iki ayrı sınıfa ayırabiliriz. object içerisinde tanımlanmış property&amp;rsquo;ler, &amp;ldquo;öz nitelik&amp;rdquo; sınıfına dahil olacaktır. yukarıdaki &lt;code&gt;Ornek&lt;/code&gt; constructor function&amp;rsquo;ında tanımlanmış olan &lt;code&gt;a&lt;/code&gt; ve &lt;code&gt;b&lt;/code&gt; nitelikleri &lt;code&gt;Ornek&lt;/code&gt; class&amp;rsquo;ından edinilmiş bir instance&amp;rsquo;ın öz niteliği olup, miras alınan property&amp;rsquo;ler ise ( prototype&amp;rsquo;dan gelen property&amp;rsquo;ler ) öz nitelik sınıfına dahil değildir. javascript&amp;rsquo;te bunu sorgulamak için &lt;strong&gt;hasOwnProperty&lt;/strong&gt; methodu kullanılabilir &lt;em&gt;(Object class&amp;rsquo;ının prototype&amp;rsquo;ından miras alınan bir method)&lt;/em&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;o.hasOwnProperty(&#39;a&#39;); // true
o.hasOwnProperty(&#39;topla&#39;); // false
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;tüm own property listesini edinmek içinse: &lt;strong&gt;Object.getOwnPropertyNames(obj)&lt;/strong&gt;, örnek: &lt;code&gt;Object.getOwnPropertyNames(o);&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;belki dikkatinizi çekmiştir, &lt;code&gt;o.hasOwnProperty&lt;/code&gt; methodunu object&amp;rsquo;den miras alıyoruz ancak &lt;code&gt;getOwnPropertyNames&lt;/code&gt; miras alınmıyor. Sebebi: getOwnPropertyNames methodu Object class&amp;rsquo;ının own property&amp;rsquo;sidir.&lt;/p&gt;

&lt;h3 id=&#34;toc_3&#34;&gt;accessor property&lt;/h3&gt;

&lt;p&gt;accessor property türündeki fark, bir property için getter/setter methodları belirleyebilmenizi sağlar. kolay bir kullanımı var, yerine göre de çok kullanışlı olacaktır.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var o = {
  n: 1,
  get a(){ return this.n; },
  set a(v){ this.n = v*v; }
};

o.a // 1
o.a = 4; 
o.a // 16
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;gördüğünüz gibi accessor property&amp;rsquo;ler &lt;strong&gt;fonksiyon-vari&lt;/strong&gt; bir syntax kullanılarak tanımlanıyor. getter fonksiyonu için &amp;ldquo;get&amp;rdquo;, setter içinse &amp;ldquo;set&amp;rdquo; keyword&amp;rsquo;ünü kullanarak fonksiyonlarınızı tanımlıyorsunuz ve fonksiyon ismi property&amp;rsquo;niz oluyor.&lt;/p&gt;

&lt;h3 id=&#34;toc_4&#34;&gt;property descriptor&lt;/h3&gt;

&lt;p&gt;genel olarak property&amp;rsquo;lerin ismi ve değeri dışında taşığı belirli özellikleri vardır. bunlar &lt;strong&gt;normal property&amp;rsquo;ler (data-property)&lt;/strong&gt; için &lt;em&gt;value,writable,enumerable ve configurable&lt;/em&gt; iken &lt;strong&gt;accessor property&amp;rsquo;ler&lt;/strong&gt; için &lt;em&gt;get,set,enumerable ve configurable&lt;/em&gt; şeklindedir. bu attribute&amp;rsquo;ları property olarak taşıyan object veri property-descriptor olarak tanımlanır.&lt;/p&gt;

&lt;h4 id=&#34;toc_5&#34;&gt;data-property&amp;rsquo;lerin attribute&amp;rsquo;ları&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;value&lt;/strong&gt;: property&amp;rsquo;nin taşıdığı değerdir, herhangi bir javascript değeri olabilir. (number,string,function,object,null,&amp;hellip;)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;writable&lt;/strong&gt;: property&amp;rsquo;nin yazılabilir olduğunu işaret eden attribute.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;enumerable&lt;/strong&gt;: property&amp;rsquo;nin &lt;em&gt;sayılabilir&lt;/em&gt; yani in/of döngülerinde listelenebilir olduğunu işaret eden attribute.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;configurable&lt;/strong&gt;: property&amp;rsquo;nin üzerine yazılabilir/silinebilir olduğunu işaret eden attribute.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;toc_6&#34;&gt;accessor-property&amp;rsquo;lerin attribute&amp;rsquo;ları&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;get&lt;/strong&gt;: property&amp;rsquo;nin getter fonksiyonu&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;set&lt;/strong&gt;: property&amp;rsquo;nin setter fonksiyonu, undefined olması durumunda property&amp;rsquo;nin yazılamaz olduğunu bildirir.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;enumerable&lt;/strong&gt;: data-property&amp;rsquo;deki gibi&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;configurable&lt;/strong&gt;: data-property&amp;rsquo;deki gibi&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;bir object&amp;rsquo;in descriptor&amp;rsquo;unu edinmek için &lt;strong&gt;Object.getOwnPropertyDescriptor(obj, prop)&lt;/strong&gt; kullanılabilir. method&amp;rsquo;un adından da anlaşılabileceği gibi &lt;strong&gt;own-property&amp;rsquo;lerin descriptor&amp;rsquo;ları edinilir&lt;/strong&gt;, miras alınan property&amp;rsquo;ler için false değeri dönecektir.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function Ornek(a,b){
  this.a = a || 0;
  this.b = b || 0;
}

Ornek.prototype.topla = function(){ return this.a+this.b; };

var o = new Ornek(1,2);

Object.getOwnPropertyDescriptor(o, &#39;topla&#39;); 
// false

Object.getOwnPropertyDescriptor(o, &#39;a&#39;);
// { value:1, writable:true, enumerable:true, configurable:true }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;descriptor tanımla işlemi ise &lt;strong&gt;Object.defineProperty(obj, prop, desc)&lt;/strong&gt; ile yapılır. burda bilmeniz gereken defineProperty ile yapılan descriptor&amp;rsquo;larda tanımlanmamış attribute&amp;rsquo;ler &lt;strong&gt;false&lt;/strong&gt; değerini alır.&lt;/p&gt;

&lt;p&gt;attribute ve accessor-property&amp;rsquo;ler için örnekler verelim. prototype üzerinden tanımlayalım, bu da object&amp;rsquo;lerin referanslarla işlendiğini görmenize yardımcı olsun.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;writable&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;Object.defineProperty(Ornek.prototype, &#39;origin&#39;, {
  value:0,
  writable:false,
  enumerable:true,
  configurable:true
});

o.origin; // 0
o.origin = 5; // hata vermez ancak çalışmaz. strict mode&#39;da hata verir.
o.origin; // 0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;writable değeri false olan bir property&amp;rsquo;ye gördüğünüz gibi yeni bir değer atanamaz. ayrıca bu örnekte gördüğünüz gibi o instance&amp;rsquo;ı &lt;em&gt;origin&lt;/em&gt; property&amp;rsquo;si eklenmeden önce instance edilmiş olsa da, &lt;strong&gt;object&amp;rsquo;lerin referance ile işlenmesinden dolayı&lt;/strong&gt; yeni property &lt;em&gt;origin&lt;/em&gt;&amp;lsquo;i de miras aldı.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;configurable&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;origin property&amp;rsquo;si read-only&amp;rsquo;dir, kendisine yeni bir değer atanamaz ancak hala configurable olduğundan descriptor&amp;rsquo;un üzerine yazılabilir.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;Object.defineProperty(Ornek.prototype, &#39;origin&#39;, {
  value:2,
});

o.origin; // 2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;burda yeni descriptor yazılarak tanımlanan &lt;em&gt;origin&lt;/em&gt; property&amp;rsquo;si tanımlanmamış attribute&amp;rsquo;ları önceki descriptor&amp;rsquo;dan &lt;strong&gt;miras&lt;/strong&gt; alır. yeni descriptor&amp;rsquo;da configurable false yapılsaydı, &lt;code&gt;delete o.origin&lt;/code&gt; false değerini dönecekti ve yeni bir descriptor ile origin&amp;rsquo;i tekrar tanımla işlemi &lt;strong&gt;hata&lt;/strong&gt; verecekti.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;enumerable&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;origin property&amp;rsquo;sinin attribute&amp;rsquo;ları üzerine yazarak devam edelim.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;Object.keys(Ornek.prototype); // listede origin de var

Object.defineProperty(Ornek.prototype, &#39;origin&#39;, {enumerable:false});

Object.keys(Ornek.prototype); // listede origin yok

// ya da

Ornek.prototype.propertyIsEnumerable(&#39;origin&#39;); // false
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;accessor property&amp;rsquo;ler içinse tanımla işlemi şu şekildedir:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;Object.defineProperty(Ornek.prototype, &#39;d&#39;, {
  get: function(){ return Math.sqrt(this.a*this.a + this.b*this.b); },
  configurable: false
});

o.d;
delete o.d; // false
Object.defineProperty(Ornek.prototype, &#39;d&#39;, {...}); // throw TypeError: Cannot redefine
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_7&#34;&gt;object attributes&lt;/h2&gt;

&lt;p&gt;javascript&amp;rsquo;te her object &lt;strong&gt;prototype&lt;/strong&gt;, &lt;strong&gt;class&lt;/strong&gt; ve &lt;strong&gt;extensible&lt;/strong&gt; attribute&amp;rsquo;larını taşır.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;prototype&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;daha önce de bahsettiğimiz gibi miras alınacak property&amp;rsquo;leri taşıyan object datadır. &amp;ldquo;.isPrototypeOf&amp;rdquo; methodu yardımıyla sorgulanabilir:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;Ornek.prototype.isPrototypeOf(o); // true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;instance tarafında prototype erişmemizi sağlayan &lt;strong&gt;&lt;strong&gt;proto&lt;/strong&gt;&lt;/strong&gt; accessor-property&amp;rsquo;si mevcuttur: &lt;code&gt;o.__proto__ === Ornek.prototype&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;class&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;object type&amp;rsquo;ı hakkında bilgi veren string değerdir. toString çağrısıyla elde edilen string değerin ikinci kısmıdır.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;extensible&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;object&amp;rsquo;e yeni bir property eklenip eklenemeyeceğini belirten değerdir. bir object&amp;rsquo;in extensible olup olmadığını sorgulamak için:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;Object.isExtensible(Ornek.prototype); // true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;bir object&amp;rsquo;i nonextensible yapmak için ise &lt;strong&gt;Object.preventExtensions(obj)&lt;/strong&gt; kullanılabilir:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;Object.preventExtensions(o); // o object&#39;ini ( Ornek instance&#39;ı ) nonextensible yaptık.
o.xyz = 1; // gecersiz olur.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;burda instance üzerinden örnek vermemin sebebi, preventExtensions &lt;strong&gt;own-property&lt;/strong&gt;&amp;lsquo;ler için geçerlidir. yani Ornek.prototype&amp;rsquo;a bir property eklediğiniz zaman bu yine miras alınır. ayrıca nonextensible yapılan bir object tekrar extensible yapılamaz.&lt;/p&gt;

&lt;p&gt;preventExtensions benzeri fonksiyonlar da mevcut: &lt;strong&gt;Object.seal(obj)&lt;/strong&gt; ve &lt;strong&gt;Object.freeze(obj)&lt;/strong&gt;, benzer şekilde object&amp;rsquo;lerin sealed ya da frozen durumları sırasıyla &lt;strong&gt;Object.isSealed(obj)&lt;/strong&gt; ve &lt;strong&gt;Object.isFrozen(obj)&lt;/strong&gt; fonksiyonları aracılığıyla sorgulanabilir.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Object.seal(o);&lt;/code&gt; ile o object&amp;rsquo;i nonextensible yaptığı gibi, object&amp;rsquo;in own-property&amp;rsquo;lerini de nonconfigurable yapar. &lt;code&gt;Object.freeze(o);&lt;/code&gt; ise seal&amp;rsquo;e artı olarak bütün own-property&amp;rsquo;leri read-only yapar.&lt;/p&gt;

&lt;p&gt;bitirirken; javascript&amp;rsquo;te oop uzun uzadıya bir yazı olabileceği için kendisinden fazla bahsedemedim ancak property&amp;rsquo;leri etkin bir şekilde kullanabileceğinizi umuyorum. oop konusu da diğer yazılara kalsın artık :)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>rsyncd, rsync daemon</title>
      <link>http://brsyuksel.github.io/post/rsync/</link>
      <pubDate>Fri, 01 Aug 2014 18:56:58 &#43;0200</pubDate>
      
      <guid>http://brsyuksel.github.io/post/rsync/</guid>
      <description>&lt;p&gt;rsync, dosya transferinden zaman kazandıracak güzel yeteneklere sahip popüler bir uygulama. local ve uzak bilgisayar üzerinde dosya transferi yapabilmenizi sağlayan rsync&amp;rsquo;in en dikkat çekici özelliği sadece değişiklikleri transfer ederek transfer noktaları arasındaki senkronizasyonu sağlamasıdır. bunun yanında diğer bir özellik olarak da linkler, soketler, device&amp;rsquo;lar, dosya sahipliği ve izinlerin kopyalanmasını destekler. rsync mirroring için en ideal yazılımdır. daha fazlası için &lt;a href=&#34;http://en.wikipedia.org/wiki/Rsync&#34; title=&#34;wikipedia-rsync&#34;&gt;burdan&lt;/a&gt; devam edin.&lt;/p&gt;

&lt;p&gt;rsync ile genelde uzak bilgisayarlar arasında ssh üzerinden bağlantı sağlanıyor. yerine göre doğru bir tercih olsa da local&amp;rsquo;de yer alan sanal makinelerde rsync&amp;rsquo;i daemon olarak kullanmak daha verimli olabilir. basit bir yapılandırma ile rsync&amp;rsquo;i daemon olarak başlatabilirsiniz.&lt;/p&gt;

&lt;p&gt;server tarafında ilk işimiz &lt;code&gt;/etc/rsyncd.conf&lt;/code&gt; dosyası ile. bu dosyada rsync daemon&amp;rsquo;u için belirli tanımlamaları yapıp sonra rsnyc&amp;rsquo;in dökümanında yer alan tabirle modüller halinde hedef klasörlerimizi tanımlayacağız.&lt;/p&gt;

&lt;p&gt;motd file=/path/to/motdfile.txt
  pid file=/var/run/rsyncd.pid&lt;/p&gt;

&lt;p&gt;[project1]
    comment=project1 rsync dir
    path=/path/to/project1
    use chroot=true
    read only=false
    log file=/path/to/logs/project1.log
    uid=0
    gid=0
    filter=&lt;em&gt;.pyc tmp/
    exclude=&lt;/em&gt;.swp
    auth users=kullanici
    secrets file=/etc/rsyncd.secrets&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;motd file&lt;/strong&gt;, login, sshd vs den de tanıdık gelecektir, &amp;ldquo;message of the day&amp;rdquo; dosyası. rsync ile bağlantı sonrasında kullanıcıya göstermek istediğiniz mesajı bir dosyaya kaydedip bu değişken ile belirtiyorsunuz.
&lt;strong&gt;pid file&lt;/strong&gt;, rsync daemon&amp;rsquo;u için pid dosyası.&lt;/p&gt;

&lt;p&gt;bu noktadan sonra modül tanımlarına geçiyoruz. ancak daha fazla global tanımlar için &lt;code&gt;man rsyncd.conf&lt;/code&gt; komutu ile man sayfasından bilgi alabilirsiniz.&lt;/p&gt;

&lt;p&gt;rsync daemon&amp;rsquo;u için modüller fark ettiğiniz gibi &lt;em&gt;[]&lt;/em&gt; içinde tanımlanıyor. bu modüllerin kendi içerisinde belirli tanımları içermesi gerekiyor ve rsync komutu ile dosya transferi sağlanırken, sunucu üzerindeki realpath&amp;rsquo;i değil, modül ismini uri&amp;rsquo;de path bilgisi olarak vermeniz gerekiyor.&lt;/p&gt;

&lt;p&gt;örnek modüldeki tanımlara bakalım.
&lt;strong&gt;comment&lt;/strong&gt;, modül hakkında bilgi. rsync ile list yaptığınız anda kullanıcıya gösteriliyor.
&lt;strong&gt;path&lt;/strong&gt;, senkronizasyon yapılacak klasör yolu.
&lt;strong&gt;use chroot&lt;/strong&gt;, dosya transferi başlamadan önce rsnyc daemonunun klasör içerisinde chroot olmasını sağlar.
&lt;strong&gt;read only&lt;/strong&gt;, default olarak true değerini alan bu parametre dosyaları &lt;strong&gt;yazılamaz&lt;/strong&gt; yapar, klasör sadece download&amp;rsquo;a açıktır.
&lt;strong&gt;log file&lt;/strong&gt;, dosya transferi log dosyası yolu.
&lt;strong&gt;uid, gid&lt;/strong&gt;, dosya transfer işlemi gerçekleştikten sonra sahipliği bu user-group olacak şekilde bu id&amp;rsquo;li kullanıcıya teslim edilir.
&lt;strong&gt;filter&lt;/strong&gt;, bu tanım ile belirlediğiniz klasör ve türdeki dosyaları download&amp;rsquo;a kapatabiliyorsunuz.
&lt;strong&gt;exclude&lt;/strong&gt;, filter gibi bu tanımla da upload anında belirlediğiniz dosyaların yüklenmesini engelleyebiliyorsunuz.
&lt;strong&gt;auth users&lt;/strong&gt;, bu modül için erişim haklarına sahip kullanıcılar.
&lt;strong&gt;secrets file&lt;/strong&gt;, kullanıcıların username:password bilgisinin yer aldığı dosya.&lt;/p&gt;

&lt;p&gt;yine daha fazla bilgi için &lt;code&gt;man rsyncd.conf&lt;/code&gt; ile man sayfasına göz atın.&lt;/p&gt;

&lt;p&gt;şimdi &lt;em&gt;kullanici&lt;/em&gt; isimli kullanıcımızı &lt;code&gt;/etc/rsyncd.secrets&lt;/code&gt; dosyasına eklememiz gerekiyor. bu dosyada kullanıcı ve şifre bilgisi &lt;strong&gt;:&lt;/strong&gt; ile kolonlara ayrılmış olup, her kullanıcı bilgisi alt alta plain text olarak yazılıyor.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;/etc/rsyncd.secrets&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;kullanici:123456SFR
  baris:sifreSFR&lt;/p&gt;

&lt;p&gt;tanımlamaları yapıktan sonra sıradaki iş rsync&amp;rsquo;i daemon olarak başlatmakta. ilk önce &lt;code&gt;/etc/services&lt;/code&gt; dosyasında rsync port ve protokol tanımının yapılıp yapılmadığını kontrol ediyoruz. yapılmamışsa aşağıdaki örnek çıktıyı bu dosyaya ekleyebilirsiniz.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cat /etc/services | grep rsync
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;rsync   873/tcp
  rsync   873/udp&lt;/p&gt;

&lt;p&gt;bu noktada önemli, internet daemon&amp;rsquo;ları bazı dağıtımlarda inet daemon&amp;rsquo;u tarafından yönetilirken bazı dağıtımlarda inetd&amp;rsquo;nin yerine gelen xinetd tarafından yönetiliyor. slackware inetd ile çalıştığından ben inetd yapılandırma dosyası hakkında bilgi verebileceğim.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;/etc/inetd.conf&lt;/code&gt; yapılan eklemeler belirli bir formatta oluyor, rsync daemonu için yapacağımız ekleme şu şekilde:&lt;/p&gt;

&lt;p&gt;rsync   stream  tcp     nowait  root   /usr/bin/rsync rsyncd &amp;ndash;daemon&lt;/p&gt;

&lt;p&gt;bu eklemeyi yapıp kaydettikten sonra inetd&amp;rsquo;ye HUP sinyali gönderip .conf dosyasını yeniden okumasını sağlıyoruz.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;kill -HUP `pidof inetd`
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;bu aşamadan sonra rsync üzerinden bağlantı gerçekleştirebilirsiniz.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;rsync -rtvh rsync://kullanici@server.ip/project1 lokal/hedef/klasor
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>pptpd ile pptp vpn server kurulumu</title>
      <link>http://brsyuksel.github.io/post/pptp/</link>
      <pubDate>Fri, 01 Aug 2014 18:54:19 &#43;0200</pubDate>
      
      <guid>http://brsyuksel.github.io/post/pptp/</guid>
      <description>

&lt;p&gt;dns çözümlerinin yetersiz kaldığı anlarda(!) vpn çözümlerine başvuruyoruz. bu dökümanda düşük bir maliyetle edinebileceğiniz vps&amp;rsquo;inizi nasıl size özel bir pptp vpn-server&amp;rsquo;a çevirebileceğinizi anlatmaya çalışacağım. ücretsiz vpn hizmetlerinin yetersiz kaldığı anlarda(!) hızlı bir çözüm olacaktır. server kurulumu fedora 19, client fedora 20 olsa da bir çok dağıtım için yapılandırma benzer olacaktır.&lt;/p&gt;

&lt;p&gt;başlamadan bahsedeyim alternatif olarak openVPN gibi çözümler mevcut ancak kaynak kullanımı, hız-performans gibi konulardan ötürü ben pptp&amp;rsquo;yi tercih ettim. yine de farklı yetenekli olan openVPN&amp;rsquo;i deneyebilirsiniz.&lt;/p&gt;

&lt;h1 id=&#34;toc_0&#34;&gt;server&lt;/h1&gt;

&lt;p&gt;pptpd paketini kurun.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;yum install pptpd
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ilk olarak pptpd ayarlarında bir kaç değişiklik yapmanız gerekiyor. &lt;code&gt;/etc/pptpd.conf&lt;/code&gt; dosyasında şu düzenlemeleri yapın.&lt;/p&gt;

&lt;p&gt;#logwtmp
  localip 10.0.0.1
  remoteip 10.0.0.100-200&lt;/p&gt;

&lt;p&gt;logwtmp satırını disable ederek connection loglarının tutulmasını kapatmış bulunuyoruz. daha fazla yapılandırma bilgisi için &lt;code&gt;man pptpd.conf&lt;/code&gt; yazarak bilgi alabilirsiniz.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;/etc/ppp/options.pptpd&lt;/code&gt; dosyasında yine bir kaç satırlık düzenleme yapmanız gerekiyor. client&amp;rsquo;ların dns hizmeti için hangi sağlayıcının kullanılacabını belirleyin. ben alttaki örnekte google dns(!) kullandım.&lt;/p&gt;

&lt;p&gt;ms-dns 8.8.8.8
  ms-dns 8.8.4.4&lt;/p&gt;

&lt;p&gt;&lt;code&gt;/etc/ppp/chap-secrets&lt;/code&gt; dosyasında uygun formatta vpn-server&amp;rsquo;ınızın kullanıcınılarını basit bir şekilde kullanıcı adı ve şifre olarak tanımlıyorsunuz.&lt;/p&gt;

&lt;p&gt;[USERNAME] pptpd [PASSWORD] *&lt;/p&gt;

&lt;p&gt;&lt;em&gt;[USERNAME]&lt;/em&gt; ve &lt;em&gt;[PASSWORD]&lt;/em&gt; alanlarını kendinize göre düzenleyin. eklemek istediğiniz kullanıcı varsa aynı dosyaya aynı formatta eklemeye devam edebilirsiniz.&lt;/p&gt;

&lt;p&gt;şimdi ip forwarding&amp;rsquo;i açmamız gerekiyor. geçici olarak açmak istediğiniz taktirde şu komutu kullanabilirsiniz:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sysctl net.ipv4.ip_forward=1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ancak olası bir reboot sonrası bu ayar default değer olan 0 değerini alacağından kalıcı olması için &lt;code&gt;/etc/sysctl.d/99-ip_forward.conf&lt;/code&gt; dosyasını oluşturup aynı komutu dosyaya girdi olarak bırakıyoruz&lt;/p&gt;

&lt;p&gt;net.ipv4.ip_forward=1&lt;/p&gt;

&lt;p&gt;ayarların uygulanması için tekrar sysctl&amp;rsquo;den yararlanıyoruz. aşağıdaki komut yardımcı olacaktır.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sysctl --system
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;bu noktadan sonra iptables&amp;rsquo;a bazı eklemeleri yapmamız gerekiyor. bunlar şu şekilde:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE
iptables --table nat --append POSTROUTING --out-interface ppp0 -j MASQUERADE
iptables -I INPUT -s 10.0.0.0/8 -i ppp0 -j ACCEPT
iptables --append FORWARD --in-interface eth0 -j ACCEPT
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;iptables girdileri yine reboot sonrası kalıcı olmayacağından girdileri &lt;code&gt;/etc/iptables/iptables.rules&lt;/code&gt; dosyasına kaydetmek kalıcılık sağlayacaktır. aşağıdaki komut aradığınız çözüm.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;iptables-save &amp;gt; /etc/iptables/iptables.rules
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;server yapılandırmasında sona geldik. şimdi iptables servisini yeniden başlatıp ve pptpd servisini başlatıp reboot sonrası otomatik başlatma için ayarlayın.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;systemctl restart iptables.service
systemctl start pptpd.service
systemctl enable pptpd.service
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;toc_1&#34;&gt;client&lt;/h1&gt;

&lt;p&gt;bu adımda client&amp;rsquo;ımızı yapılandırıp vpn-server&amp;rsquo;ımıza bağlanacağız.&lt;/p&gt;

&lt;p&gt;client&amp;rsquo;da pptp paketine ihtiyaç duyuyoruz. pptp paketini yükleyin.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;yum install pptp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;bağlanacağımız vpn-server&amp;rsquo;ları &lt;code&gt;/etc/ppp/peers/&lt;/code&gt; klasörü altında belirli bir formatta tanımlıyoruz. bu noktada kullanacağınız vpn-server&amp;rsquo;ı tanımladığınız dosya adı önemli çünkü ilerde bağlantı sağlanırken kullanılan komutta bu dosya adını parametre olarak vereceğiz.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;/etc/ppp/peers/ozelvpn&lt;/code&gt; dosyası şu şekilde olabilir.&lt;/p&gt;

&lt;p&gt;pty &amp;ldquo;pptp [SERVERIP] &amp;ndash;nolaunchpppd&amp;rdquo;
  name [USERNAME]
  password [PASSWORD]
  remotename PPTP
  require-mppe-128&lt;/p&gt;

&lt;p&gt;örnekteki &lt;em&gt;[SERVERIP]&lt;/em&gt; yerine VPS&amp;rsquo;inizin IP adresini yazmalısınız. &lt;em&gt;[USERNAME]&lt;/em&gt; ve &lt;em&gt;[PASSWORD]&lt;/em&gt; alanlarına server&amp;rsquo;da &lt;code&gt;/etc/ppp/chap-secrets&lt;/code&gt; dosyasında tanımladığınız uygun kullanıcının bilgilerini girmeniz gerekiyor.&lt;/p&gt;

&lt;p&gt;şimdi vpn-serverımızla bağlantıyı sağlayalım.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;pppd call ozelvpn
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;bu komutu çalıştırdıktan sonra &lt;strong&gt;ozelvpn&lt;/strong&gt; olarak tanımladığınız vpn&amp;rsquo;inize bağlanmış olacaksınız ancak tunnelling hala gerçekleşmiyor. vpn ile olan bağlantınızı kontrol etmek için aşağıdaki komutu kullanabilirsiniz.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;tail -f /var/log/messages
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;tunnelling&amp;rsquo;i gerçekleştirmek için bir route işlemine ihtiyaç duyuyor olacaksınız. bu işlemi de şu şekilde gerçekleştirip son adımı tamamlamış olacaksınız ve artık packet&amp;rsquo;ler vpn üzerinden dolaşacak. ip adres kontrolü sağlayan sitelerden ip adresinizi &lt;a href=&#34;http://ipadresimnedir.org&#34; title=&#34;ipadresimnedir.org&#34;&gt;ipadresimnedir.org&lt;/a&gt; sitesinden ya da hiç vakit kaybetmeden özgürlüğünüzü, 21.yy dünyasında demoktratik haklarınızın engellenip engellenmediğini(!) kontrol edebilirsiniz.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;route add default dev ppp0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;route işlemi de kalıcı değildir. pppd call işleminden sonra otomatik olarak yapılmasını istiyorsanız &lt;code&gt;/etc/ppp/ip-up.local&lt;/code&gt; dosyasını oluşturup şu girdiyi bırakın:&lt;/p&gt;

&lt;p&gt;#!/bin/bash
  route add default dev ppp0&lt;/p&gt;

&lt;p&gt;daha sonra dosyayı executable yapın.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;chmod +x /etc/ppp/ip-up.local
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;bu işlemden sonra her &lt;code&gt;pppd call ozelvpn&lt;/code&gt; komutundan sonra route işlemi gerçekleştirilmiş olacak.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>slackware tagfile</title>
      <link>http://brsyuksel.github.io/post/slackware-tagfiles/</link>
      <pubDate>Tue, 01 Jul 2014 18:58:47 &#43;0200</pubDate>
      
      <guid>http://brsyuksel.github.io/post/slackware-tagfiles/</guid>
      <description>&lt;p&gt;slackware kurulumu yaparken siz de benim gibi yüklü miktarda paket yüklemek istemiyor ve bunun sonucu olarak yükleme sırasında &lt;a href=&#34;http://docs.slackware.com/_media/slackware:setup_install_cl.png&#34; title=&#34;resim&#34;&gt;select prompting mode&lt;/a&gt; menüsünde &lt;strong&gt;expert&lt;/strong&gt; seçeneği ile devam edip yüklenecek paketleri tek tek seçiyorsanız, yine benim gibi çok sıkılıyorsunuzdur.&lt;/p&gt;

&lt;p&gt;bu işlemi sonraki yüklemelerde otomatize etmek için slackware kurulumunda &lt;strong&gt;tagfile&lt;/strong&gt; seçeneği mevcut. slackware tagfile&amp;rsquo;ları, yükleme medyasında paketlerin bulunduğu dizinde &lt;em&gt;( 32-bit için &lt;strong&gt;/slackware&lt;/strong&gt;, 64-bit için &lt;strong&gt;/slackware64&lt;/strong&gt; )&lt;/em&gt; her kategori altında &lt;strong&gt;tagfile&lt;/strong&gt; ismiyle bulunuyor. bu dosyaları direkt olarak düzenleyebilirsiniz de ancak yeni bir klasör oluşturup paketleri içeren klasör ile aynı dizin yapısını oluşturarak her kategori için tagfile oluşturmak daha doğru olacaktır.&lt;/p&gt;

&lt;p&gt;paketlerin bulunduğu dizine girin ve bu komutu çalıştırın: &lt;code&gt;mkdir ~/tagfiles &amp;amp;&amp;amp; cp -Rv --parents */tagfile ~/tagfiles/&lt;/code&gt;
bu komut ile tagfile dizininizi oluşturmuş olacaksınız.&lt;/p&gt;

&lt;p&gt;sonrasında paket kategorileri altındaki tagfile&amp;rsquo;ları kendinize göre düzenlemelisiniz. tagfile dosyasını açıp paket isimlerinin karşılığına, yüklenmesini istediğiniz paket için &lt;strong&gt;ADD&lt;/strong&gt;, yüklenmesini istemediğiniz paket için &lt;strong&gt;SKP&lt;/strong&gt; ve kullanıcıya sorarak yüklenecek paketler için &lt;strong&gt;REC&lt;/strong&gt; yazmalısınız. tagfile oluşturma işlemi bu kadar basit.&lt;/p&gt;

&lt;p&gt;tagfile&amp;rsquo;ları da düzenledikten sonra kurulum anında &lt;em&gt;( kurulum medyanız oluşturduğunuz tagfile klasörünü barındırmalı )&lt;/em&gt; &lt;a href=&#34;http://docs.slackware.com/_media/slackware:setup_install_cl.png&#34; title=&#34;resim&#34;&gt;select prompting mode&lt;/a&gt;&amp;lsquo;da &lt;strong&gt;tagpath&lt;/strong&gt; seçeneği ile devam edip tagfiles klasörünün tam yolunu vermelisiniz. bu işlemden sonra yükleme işlemi başlayacak ve slackware paketleri otomatik olarak yüklenecektir.&lt;/p&gt;

&lt;p&gt;ben kendi tagfile&amp;rsquo;larımı &lt;a href=&#34;https://github.com/brsyuksel/slackware-tagfiles.git&#34; title=&#34;slackware tagfiles&#34;&gt;github hesabımda&lt;/a&gt; paylaştım, kullanmak isteyenler için özetle; base slackware yükleniyor, desktop environment&amp;rsquo;ler (gnome,kde,xfce,fluxbox,&amp;hellip;), display managerlar (gdm,kdm,xdm,&amp;hellip;), multimedya uygulamaları, rss okuyucu-irc-pidgin gibi mesajlaşma uygulamaları, x&amp;rsquo;in bazı uygulamaları yüklenmiyor, sonrasında slackware&amp;rsquo;ı kendim yapılandırarak dilediğim gibi kullanıyorum.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>slackware pppd ve updown scripti</title>
      <link>http://brsyuksel.github.io/post/updown/</link>
      <pubDate>Sun, 01 Jun 2014 19:09:38 &#43;0200</pubDate>
      
      <guid>http://brsyuksel.github.io/post/updown/</guid>
      <description>&lt;p&gt;slackware&amp;rsquo;da pptp-client uygulamasını yükledikten sonra, uygulamanın fedora&amp;rsquo;daki gibi route tablosunu tunnelling&amp;rsquo;i sağlayacak şekilde düzenlemediğini fark ettim. açıkcası bu sorun sürüm farklılığından mı, script/conf eksikliğinden mi ya da başka bir sebepten mi kaynaklanıyor araştırmadım, pppd&amp;rsquo;nin script&amp;rsquo;lerini kullanarak çözüme gitmek yeterince vakit kazandırdı.&lt;/p&gt;

&lt;p&gt;pptp sağlayıcısı ile bağlantı sağlandıktan sonra, default route girişini her seferinde elle girmek yerine &lt;strong&gt;/etc/ppp&lt;/strong&gt; klasörü altında executable bir &lt;strong&gt;ip-up&lt;/strong&gt; scripti oluşturup otomatik olarak çalışmasını sağlayabiliyorsunuz. slackware altında nedense &lt;strong&gt;host target route&lt;/strong&gt; girişi otomatik olarak yapılmıyor, bu script ile bu sorunu aşabilirsiniz. ancak &lt;strong&gt;birden çok&lt;/strong&gt; sağlayıcı kullanıyorsanız, bu script&amp;rsquo;in farklı sağlayıcılar için otomatik olarak çalıştırılması anlamsız bir hale geliyor. sağlayıcının kendi ip adresini &lt;strong&gt;host target&lt;/strong&gt; olarak route tablosuna eklemezseniz, başarısız bir sonuç alırsınız.&lt;/p&gt;

&lt;p&gt;bu soruna çözüm olması için &lt;strong&gt;updown&lt;/strong&gt; adını verdiğim basit bir script oluşturdum. pppd&amp;rsquo;nin bir özelliği olan ipparam&amp;rsquo;dan yararlandım. peer dosyasında tanımladığınız &lt;strong&gt;ipparam&lt;/strong&gt; değeri, bağlantı durumlarında &lt;strong&gt;ip-up&lt;/strong&gt; ve &lt;strong&gt;ip-down&lt;/strong&gt; script&amp;rsquo;lerine &lt;strong&gt;parametre&lt;/strong&gt; olarak iletiliyor. updown, bu parametreye uygun olarak düzenlenmiş script&amp;rsquo;i çalıştırarak bağlantı sonrası yapılması gereken rutinleri, kolay yönetilebilir hale getiriyor.&lt;/p&gt;

&lt;p&gt;vpnbook serverlarını için peer dosyaları oluşturup updown&amp;rsquo;ın kullanımını özetleyeyim.&lt;/p&gt;

&lt;p&gt;öncelikle updown script&amp;rsquo;ini &lt;strong&gt;/etc/ppp&lt;/strong&gt; klasörü altına indirin:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cd /etc/ppp; wget https://raw.githubusercontent.com/brsyuksel/pppd-updown/master/updown &amp;amp;&amp;amp; chmod +x updown
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;/etc/ppp&lt;/strong&gt; altında &lt;strong&gt;ip-up&lt;/strong&gt; ve &lt;strong&gt;ip-down&lt;/strong&gt; scriptleriniz varsa, yedekledikten sonra silin.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;/etc/ppp/updown link
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;komutunu vererek, updown&amp;rsquo;ın ip-up ve ip-down adında &lt;strong&gt;kendisine linklenmiş symbolic linkler&lt;/strong&gt; oluşturmasını sağlayın.&lt;/p&gt;

&lt;p&gt;vpnbook us serveri için &lt;code&gt;/etc/ppp/peers&lt;/code&gt; klasörü altında vpnbookus dosyasını oluşturun ve şu şekilde düzenleyin:&lt;/p&gt;

&lt;p&gt;pty &amp;ldquo;pptp us1.vpnbook.com &amp;ndash;nolaunchpppd&amp;rdquo;
  name vpnbook
  password GUNCELVPNBOOKSIFRESI
  remotename PPTP
  require-mppe-128
  lock
  nobsdcomp
  nodeflate
  ipparam vpnbookus&lt;/p&gt;

&lt;p&gt;bu noktada &lt;strong&gt;ipparam vpnbookus&lt;/strong&gt; önemli. updown ile bu parametre için basit bir script oluşturup rutinlerin yönetilmesini sağlayacağız.&lt;/p&gt;

&lt;p&gt;updown ile vpnbookus parametresi için manager script&amp;rsquo;i oluşturalım. bu komutla template script&amp;rsquo;i oluşturabilirsiniz:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;/etc/ppp/updown template vpnbookus
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;bu komutu verdikten sonra updown.vpnbookus adında basit bir script editörünüzde açılacak ve düzenlemeniz istenecek. bağlantı sağlandığı zaman bu script içerisinden start fonksiyonu, bağlantı kapandığında ise stop fonksiyonu çalıştırılıyor. durumlara göre route işlemlerini ve rutinleri yapmalısınız. vpnbook us server&amp;rsquo;ı için şu şekilde düzenleyin ( &lt;strong&gt;device interface, gateway gibi parametreleri kendinize göre düzenlemeyi unutmayın&lt;/strong&gt; ) :&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;start(){
# us1.vpnbook.com ip addr: 198.7.62.204

# tunnelling icin gerekli route tablosu.
/sbin/route add -host 198.7.62.204 gw 192.168.1.1 dev wlan0
/sbin/route add default dev ppp0
/sbin/route del default dev wlan0

# nameserver gibi rutinler vs.
cat &amp;lt;&amp;lt; EOF &amp;gt; /etc/resolv.conf
nameserver 8.8.8.8
nameserver 8.8.4.4
EOF

}

stop(){
/sbin/route del -host 198.7.62.204 dev wlan0
/sbin/route add default gw 192.168.1.1 dev wlan0
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ve artık bağlantınızı sağlayabilirsiniz: &lt;code&gt;pppd call vpnbookus&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;bu noktadan sonra yine örnek olarak vpnbook eu serverları için aynı yolu izleyerek configuration&amp;rsquo;ları tamamlayıp ve geçerli bağlantıyı kapattıktan sonra diğer bir server&amp;rsquo;a bağlantıyı &lt;code&gt;pppd call PEERDOSYASIADI&lt;/code&gt; komutuyla kolayca sağlayabilirsiniz.&lt;/p&gt;

&lt;p&gt;updown gibi basit bir script için fazlasıyla uzunca bir döküman oldu sanırım :)&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>