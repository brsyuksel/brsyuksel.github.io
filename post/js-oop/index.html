<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">

  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    
      javascript&#39;te property kavramları ve oop &middot; barış yüksel
    
  </title>

  
  <link rel="stylesheet" href="/css/poole.css">
  <link rel="stylesheet" href="/css/syntax.css">
  <link rel="stylesheet" href="/css/lanyon.css">
  <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=PT+Serif:400,400italic,700|PT+Sans:400">

  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/assets/apple-touch-icon-144-precomposed.png">
  <link rel="shortcut icon" href="/assets/favicon.ico">

  
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml">
</head>


  <body>

    
<input type="checkbox" class="sidebar-checkbox" id="sidebar-checkbox">


<div class="sidebar" id="sidebar">
  <div class="sidebar-item">
    <p>barış yüksel</p>
    <p><em>python, go, c, linux</em></p>
    <p><a href="https://twitter.com/brsyuksel">twitter</a> &middot; <a href="https://github.com/brsyuksel">github</a> &middot; <a href="https://www.linkedin.com/pub/bar%C4%B1%C5%9F-y%C3%BCksel/54/178/273">linkedin</a></p>

  </div>

  <nav class="sidebar-nav">
    <a class="sidebar-nav-item " href="/">home</a>
    <a class="sidebar-nav-item " href="/post">posts</a>

    
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    

  </nav>

  <div class="sidebar-item">
    <p>&copy; barış yüksel 2014.</p>
  </div>
</div>


    
    <div class="wrap">
      <div class="masthead">
        <div class="container">
          <h3 class="masthead-title">
            <a href="/" title="Home">barış yüksel</a>
            <small>in code we trust</small>
          </h3>
        </div>
      </div>

      <div class="container content">


<div class="post">
  <h1 class="post-title">javascript&#39;te property kavramları ve oop</h1>
  <span class="post-date">1 jan, 2014</span>
  

<p>bir back-end developer olarak genel anlamda javascript&rsquo;i uygulamaların arayüzünde fonksiyonelliğini sağlayacak kadar kullandım. bir çok back-end developer arkadaş da benimle aynı konumdadır diye düşünüyorum. ancak javascript&rsquo;i server-side&rsquo;da kullanmaya başladığınız zaman iş değişiyor ve browser üzerinde yeterli gelen bilginize başvurduğunuzda durum keyifsiz bir hal almaya başlıyor. dilin esnekliğini, base method&rsquo;larını, yardımcı fonksiyonlarını bilmeden istenildiği kadar düzenli bir kod yazılsa da ( örneğin biz coffeescript&rsquo;ten yararlanıyoruz ) başarılı olabileceğini düşünmüyorum. bu nedenle javascript&rsquo;te belirli kavramları öğrenip burda paylaşmak istedim. bu dökümanda değişken türleri, dil yapısı, döngüler vb. gibi temel konular yerine özellikle object-oriented programming&rsquo;de başvurabileceğiniz bazı kavramlarla karşılaşacaksınız.</p>

<h1 id="toc_0">objects</h1>

<p>object veri türü javascript&rsquo;in en temel veri türlerinden birisi. basitçe <code>{}</code> kullanarak oluşturduğumuz object türünü mdn ( mozilla developer network ) <strong>&ldquo;property çantası&rdquo;</strong> adıyla güzel bir tanıma kavuşturmuş. burda object veri türünün tanımı yerine bu yazıda ihtiyacımız olan bir özelliği üzerinde duracağım.</p>

<p>javascript&rsquo;te diğer türlerden ziyade object&rsquo;ler referance&rsquo;larıyla işlenir. cümlelerle ifade etmektense basit bir örnek daha yararlı olacak:</p>

<pre><code class="language-javascript">var x = {}; // bos bir object
var y = x; // y, x'in bir kopyasi degil, bir referance
x.a = 1;
console.log(y.a); // 1
</code></pre>

<p>yukarıdaki örnekte görüldüğü üzere y değişkeni x&rsquo;i referans alır ve x&rsquo;e eklenen her property y tarafında da erişilebilirdir.</p>

<p>kavramların anlaşılabilir olması açısından javascript&rsquo;te object oluşturma yöntemlerine de bakalım. ilki az önce de bahsettiğimiz gibi <code>{}</code> deyimi yardımıyla:</p>

<pre><code class="language-javascript">var o = {
  n: 1,
  b: true,
  s: &quot;value&quot;,
  f: function(){},
  z: null
};
</code></pre>

<p>ikincisi <strong>Object</strong> class&rsquo;ının <strong>create</strong> methodu kullanılarak:</p>

<pre><code class="language-javascript">var o = Object.create({n:1, b:true});
</code></pre>

<p>Object.create method&rsquo;unun asıl kullanımı şu şekilde ancak bu yazı sonuna kalsın: <strong>Object.create(prototype <em>[, properties]</em>)</strong>
hızlıca bu tanım doğrultusunda doğru bir kullanım aslında şu şekilde olmalıydı:</p>

<pre><code class="language-javascript">var o = Object.create(Object.prototype, {n:{value:1}, b:{value:true}});
</code></pre>

<p>Son object oluşturma yöntemi ise <strong>constructor function</strong> tanımlayıp instance edinerek:</p>

<pre><code class="language-javascript">function anO(n){
  this.s = &quot;value&quot;;
  this.n = n; 
}

var o = new anO(1);
</code></pre>

<h2 id="toc_1">prototype</h2>

<p>javascript&rsquo;te object-oriented programming dökümanlarına baktığınız zaman <strong>prototype</strong> kavramı ile karşılaşmanız kaçınılmazdır. prototype, oluşturduğunuz instance&rsquo;ların miras alacağı property&rsquo;leri barındıran bir object. <code>new</code> <strong>keyword</strong>&lsquo;ü kullanarak oluşturduğunuz instance, <strong>class&rsquo;ının prototype object&rsquo;indeki tanımlı property&rsquo;leri miras alarak</strong> oluşturulur. basit bir örnek vermek gerekirse <code>var a = new Array(1,2,3);</code> şeklinde oluşturduğunuz bir <code>a</code> değişkeni, <strong>Array.prototype</strong> object&rsquo;inden <strong>push</strong> methodunu miras alır.</p>

<p>az önceki <strong>Object.create</strong> method&rsquo;unun kullanımını şimdi fark etmiş olmalısınız, <strong>ilk parametre miras alınacak prototype, ikinci parametre ise instance&rsquo;ın kendi property&rsquo;leri</strong> şeklinde. biz ilk kullanımda aslında kendisine <code>{n:1, b:true}</code> şeklinde tanımlı bir <strong>prototype</strong> vermiştik ve <code>o</code> değişkeni bu prototype&rsquo;dan property&rsquo;leri miras almıştı.</p>

<p>anlaşıldığı gibi, class-based dillere nazaran prototype-based bir dil olan javascript&rsquo;te bir class tanımlamak istediğinizde instance tarafından miras alınacak property&rsquo;leri prototype&rsquo;ına tanımlayacaksınız. bir örnek:</p>

<pre><code class="language-javascript">function Ornek(a,b){
  this.a = a || 0;
  this.b = b || 0;
}

Ornek.prototype.topla = function(){ return this.a+this.b; };

var o = new Ornek(1,2);
console.log( o.topla() );
</code></pre>

<h2 id="toc_2">property</h2>

<p>property&rsquo;ler object&rsquo;lerde key-value olarak taşınan değerler demiştik. bu genel başlık altında property&rsquo;lerin türleri ve özelliklerini inceleyeceğiz.</p>

<p>ilk olarak javascript object&rsquo;lerinde <strong>&ldquo;öz nitelik&rdquo; (own-property)</strong> kavramına değinelim. adında da anlaşılabileceği gibi, miras alınan property&rsquo;ler ile initial değer alarak tanımlanmış property&rsquo;leri iki ayrı sınıfa ayırabiliriz. object içerisinde tanımlanmış property&rsquo;ler, &ldquo;öz nitelik&rdquo; sınıfına dahil olacaktır. yukarıdaki <code>Ornek</code> constructor function&rsquo;ında tanımlanmış olan <code>a</code> ve <code>b</code> nitelikleri <code>Ornek</code> class&rsquo;ından edinilmiş bir instance&rsquo;ın öz niteliği olup, miras alınan property&rsquo;ler ise ( prototype&rsquo;dan gelen property&rsquo;ler ) öz nitelik sınıfına dahil değildir. javascript&rsquo;te bunu sorgulamak için <strong>hasOwnProperty</strong> methodu kullanılabilir <em>(Object class&rsquo;ının prototype&rsquo;ından miras alınan bir method)</em>:</p>

<pre><code class="language-javascript">o.hasOwnProperty('a'); // true
o.hasOwnProperty('topla'); // false
</code></pre>

<p>tüm own property listesini edinmek içinse: <strong>Object.getOwnPropertyNames(obj)</strong>, örnek: <code>Object.getOwnPropertyNames(o);</code></p>

<p>belki dikkatinizi çekmiştir, <code>o.hasOwnProperty</code> methodunu object&rsquo;den miras alıyoruz ancak <code>getOwnPropertyNames</code> miras alınmıyor. Sebebi: getOwnPropertyNames methodu Object class&rsquo;ının own property&rsquo;sidir.</p>

<h3 id="toc_3">accessor property</h3>

<p>accessor property türündeki fark, bir property için getter/setter methodları belirleyebilmenizi sağlar. kolay bir kullanımı var, yerine göre de çok kullanışlı olacaktır.</p>

<pre><code class="language-javascript">var o = {
  n: 1,
  get a(){ return this.n; },
  set a(v){ this.n = v*v; }
};

o.a // 1
o.a = 4; 
o.a // 16
</code></pre>

<p>gördüğünüz gibi accessor property&rsquo;ler <strong>fonksiyon-vari</strong> bir syntax kullanılarak tanımlanıyor. getter fonksiyonu için &ldquo;get&rdquo;, setter içinse &ldquo;set&rdquo; keyword&rsquo;ünü kullanarak fonksiyonlarınızı tanımlıyorsunuz ve fonksiyon ismi property&rsquo;niz oluyor.</p>

<h3 id="toc_4">property descriptor</h3>

<p>genel olarak property&rsquo;lerin ismi ve değeri dışında taşığı belirli özellikleri vardır. bunlar <strong>normal property&rsquo;ler (data-property)</strong> için <em>value,writable,enumerable ve configurable</em> iken <strong>accessor property&rsquo;ler</strong> için <em>get,set,enumerable ve configurable</em> şeklindedir. bu attribute&rsquo;ları property olarak taşıyan object veri property-descriptor olarak tanımlanır.</p>

<h4 id="toc_5">data-property&rsquo;lerin attribute&rsquo;ları</h4>

<ul>
<li><strong>value</strong>: property&rsquo;nin taşıdığı değerdir, herhangi bir javascript değeri olabilir. (number,string,function,object,null,&hellip;)</li>
<li><strong>writable</strong>: property&rsquo;nin yazılabilir olduğunu işaret eden attribute.</li>
<li><strong>enumerable</strong>: property&rsquo;nin <em>sayılabilir</em> yani in/of döngülerinde listelenebilir olduğunu işaret eden attribute.</li>
<li><strong>configurable</strong>: property&rsquo;nin üzerine yazılabilir/silinebilir olduğunu işaret eden attribute.</li>
</ul>

<h4 id="toc_6">accessor-property&rsquo;lerin attribute&rsquo;ları</h4>

<ul>
<li><strong>get</strong>: property&rsquo;nin getter fonksiyonu</li>
<li><strong>set</strong>: property&rsquo;nin setter fonksiyonu, undefined olması durumunda property&rsquo;nin yazılamaz olduğunu bildirir.</li>
<li><strong>enumerable</strong>: data-property&rsquo;deki gibi</li>
<li><strong>configurable</strong>: data-property&rsquo;deki gibi</li>
</ul>

<p>bir object&rsquo;in descriptor&rsquo;unu edinmek için <strong>Object.getOwnPropertyDescriptor(obj, prop)</strong> kullanılabilir. method&rsquo;un adından da anlaşılabileceği gibi <strong>own-property&rsquo;lerin descriptor&rsquo;ları edinilir</strong>, miras alınan property&rsquo;ler için false değeri dönecektir.</p>

<pre><code class="language-javascript">function Ornek(a,b){
  this.a = a || 0;
  this.b = b || 0;
}

Ornek.prototype.topla = function(){ return this.a+this.b; };

var o = new Ornek(1,2);

Object.getOwnPropertyDescriptor(o, 'topla'); 
// false

Object.getOwnPropertyDescriptor(o, 'a');
// { value:1, writable:true, enumerable:true, configurable:true }
</code></pre>

<p>descriptor tanımla işlemi ise <strong>Object.defineProperty(obj, prop, desc)</strong> ile yapılır. burda bilmeniz gereken defineProperty ile yapılan descriptor&rsquo;larda tanımlanmamış attribute&rsquo;ler <strong>false</strong> değerini alır.</p>

<p>attribute ve accessor-property&rsquo;ler için örnekler verelim. prototype üzerinden tanımlayalım, bu da object&rsquo;lerin referanslarla işlendiğini görmenize yardımcı olsun.</p>

<ul>
<li><strong>writable</strong></li>
</ul>

<pre><code class="language-javascript">Object.defineProperty(Ornek.prototype, 'origin', {
  value:0,
  writable:false,
  enumerable:true,
  configurable:true
});

o.origin; // 0
o.origin = 5; // hata vermez ancak çalışmaz. strict mode'da hata verir.
o.origin; // 0
</code></pre>

<p>writable değeri false olan bir property&rsquo;ye gördüğünüz gibi yeni bir değer atanamaz. ayrıca bu örnekte gördüğünüz gibi o instance&rsquo;ı <em>origin</em> property&rsquo;si eklenmeden önce instance edilmiş olsa da, <strong>object&rsquo;lerin referance ile işlenmesinden dolayı</strong> yeni property <em>origin</em>&lsquo;i de miras aldı.</p>

<ul>
<li><strong>configurable</strong></li>
</ul>

<p>origin property&rsquo;si read-only&rsquo;dir, kendisine yeni bir değer atanamaz ancak hala configurable olduğundan descriptor&rsquo;un üzerine yazılabilir.</p>

<pre><code class="language-javascript">Object.defineProperty(Ornek.prototype, 'origin', {
  value:2,
});

o.origin; // 2
</code></pre>

<p>burda yeni descriptor yazılarak tanımlanan <em>origin</em> property&rsquo;si tanımlanmamış attribute&rsquo;ları önceki descriptor&rsquo;dan <strong>miras</strong> alır. yeni descriptor&rsquo;da configurable false yapılsaydı, <code>delete o.origin</code> false değerini dönecekti ve yeni bir descriptor ile origin&rsquo;i tekrar tanımla işlemi <strong>hata</strong> verecekti.</p>

<ul>
<li><strong>enumerable</strong></li>
</ul>

<p>origin property&rsquo;sinin attribute&rsquo;ları üzerine yazarak devam edelim.</p>

<pre><code class="language-javascript">Object.keys(Ornek.prototype); // listede origin de var

Object.defineProperty(Ornek.prototype, 'origin', {enumerable:false});

Object.keys(Ornek.prototype); // listede origin yok

// ya da

Ornek.prototype.propertyIsEnumerable('origin'); // false
</code></pre>

<p>accessor property&rsquo;ler içinse tanımla işlemi şu şekildedir:</p>

<pre><code class="language-javascript">Object.defineProperty(Ornek.prototype, 'd', {
  get: function(){ return Math.sqrt(this.a*this.a + this.b*this.b); },
  configurable: false
});

o.d;
delete o.d; // false
Object.defineProperty(Ornek.prototype, 'd', {...}); // throw TypeError: Cannot redefine
</code></pre>

<h2 id="toc_7">object attributes</h2>

<p>javascript&rsquo;te her object <strong>prototype</strong>, <strong>class</strong> ve <strong>extensible</strong> attribute&rsquo;larını taşır.</p>

<ul>
<li><strong>prototype</strong></li>
</ul>

<p>daha önce de bahsettiğimiz gibi miras alınacak property&rsquo;leri taşıyan object datadır. &ldquo;.isPrototypeOf&rdquo; methodu yardımıyla sorgulanabilir:</p>

<pre><code class="language-javascript">Ornek.prototype.isPrototypeOf(o); // true
</code></pre>

<p>instance tarafında prototype erişmemizi sağlayan <strong><strong>proto</strong></strong> accessor-property&rsquo;si mevcuttur: <code>o.__proto__ === Ornek.prototype</code></p>

<ul>
<li><strong>class</strong></li>
</ul>

<p>object type&rsquo;ı hakkında bilgi veren string değerdir. toString çağrısıyla elde edilen string değerin ikinci kısmıdır.</p>

<ul>
<li><strong>extensible</strong></li>
</ul>

<p>object&rsquo;e yeni bir property eklenip eklenemeyeceğini belirten değerdir. bir object&rsquo;in extensible olup olmadığını sorgulamak için:</p>

<pre><code class="language-javascript">Object.isExtensible(Ornek.prototype); // true
</code></pre>

<p>bir object&rsquo;i nonextensible yapmak için ise <strong>Object.preventExtensions(obj)</strong> kullanılabilir:</p>

<pre><code class="language-javascript">Object.preventExtensions(o); // o object'ini ( Ornek instance'ı ) nonextensible yaptık.
o.xyz = 1; // gecersiz olur.
</code></pre>

<p>burda instance üzerinden örnek vermemin sebebi, preventExtensions <strong>own-property</strong>&lsquo;ler için geçerlidir. yani Ornek.prototype&rsquo;a bir property eklediğiniz zaman bu yine miras alınır. ayrıca nonextensible yapılan bir object tekrar extensible yapılamaz.</p>

<p>preventExtensions benzeri fonksiyonlar da mevcut: <strong>Object.seal(obj)</strong> ve <strong>Object.freeze(obj)</strong>, benzer şekilde object&rsquo;lerin sealed ya da frozen durumları sırasıyla <strong>Object.isSealed(obj)</strong> ve <strong>Object.isFrozen(obj)</strong> fonksiyonları aracılığıyla sorgulanabilir.</p>

<p><code>Object.seal(o);</code> ile o object&rsquo;i nonextensible yaptığı gibi, object&rsquo;in own-property&rsquo;lerini de nonconfigurable yapar. <code>Object.freeze(o);</code> ise seal&rsquo;e artı olarak bütün own-property&rsquo;leri read-only yapar.</p>

<p>bitirirken; javascript&rsquo;te oop uzun uzadıya bir yazı olabileceği için kendisinden fazla bahsedemedim ancak property&rsquo;leri etkin bir şekilde kullanabileceğinizi umuyorum. oop konusu da diğer yazılara kalsın artık :)</p>

</div>

      </div>
    </div>

    <label for="sidebar-checkbox" class="sidebar-toggle"></label>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-49309607-1', 'auto');
    ga('send', 'pageview');

  </script>
  </body>
</html>

