<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
      <title>Prototype on barış yüksel </title>
      <generator uri="https://hugo.spf13.com">Hugo</generator>
    <link>http://brsyuksel.github.io/tags/prototype/index.xml/</link>
    <language>tr_TR</language>
    
    
    <updated>Mon, 01 Sep 2014 18:46:47 &#43;0200</updated>
    
    <item>
      <title>javascript&#39;te property kavramları ve oop</title>
      <link>http://brsyuksel.github.io/post/js-oop/</link>
      <pubDate>Mon, 01 Sep 2014 18:46:47 &#43;0200</pubDate>
      
      <guid>http://brsyuksel.github.io/post/js-oop/</guid>
      <description>

&lt;p&gt;bir back-end developer olarak genel anlamda javascript&amp;rsquo;i uygulamaların arayüzünde fonksiyonelliğini sağlayacak kadar kullandım. bir çok back-end developer arkadaş da benimle aynı konumdadır diye düşünüyorum. ancak javascript&amp;rsquo;i server-side&amp;rsquo;da kullanmaya başladığınız zaman iş değişiyor ve browser üzerinde yeterli gelen bilginize başvurduğunuzda durum keyifsiz bir hal almaya başlıyor. dilin esnekliğini, base method&amp;rsquo;larını, yardımcı fonksiyonlarını bilmeden istenildiği kadar düzenli bir kod yazılsa da ( örneğin biz coffeescript&amp;rsquo;ten yararlanıyoruz ) başarılı olabileceğini düşünmüyorum. bu nedenle javascript&amp;rsquo;te belirli kavramları öğrenip burda paylaşmak istedim. bu dökümanda değişken türleri, dil yapısı, döngüler vb. gibi temel konular yerine özellikle object-oriented programming&amp;rsquo;de başvurabileceğiniz bazı kavramlarla karşılaşacaksınız.&lt;/p&gt;

&lt;h1 id=&#34;toc_0&#34;&gt;objects&lt;/h1&gt;

&lt;p&gt;object veri türü javascript&amp;rsquo;in en temel veri türlerinden birisi. basitçe &lt;code&gt;{}&lt;/code&gt; kullanarak oluşturduğumuz object türünü mdn ( mozilla developer network ) &lt;strong&gt;&amp;ldquo;property çantası&amp;rdquo;&lt;/strong&gt; adıyla güzel bir tanıma kavuşturmuş. burda object veri türünün tanımı yerine bu yazıda ihtiyacımız olan bir özelliği üzerinde duracağım.&lt;/p&gt;

&lt;p&gt;javascript&amp;rsquo;te diğer türlerden ziyade object&amp;rsquo;ler referance&amp;rsquo;larıyla işlenir. cümlelerle ifade etmektense basit bir örnek daha yararlı olacak:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var x = {}; // bos bir object
var y = x; // y, x&#39;in bir kopyasi degil, bir referance
x.a = 1;
console.log(y.a); // 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;yukarıdaki örnekte görüldüğü üzere y değişkeni x&amp;rsquo;i referans alır ve x&amp;rsquo;e eklenen her property y tarafında da erişilebilirdir.&lt;/p&gt;

&lt;p&gt;kavramların anlaşılabilir olması açısından javascript&amp;rsquo;te object oluşturma yöntemlerine de bakalım. ilki az önce de bahsettiğimiz gibi &lt;code&gt;{}&lt;/code&gt; deyimi yardımıyla:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var o = {
  n: 1,
  b: true,
  s: &amp;quot;value&amp;quot;,
  f: function(){},
  z: null
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ikincisi &lt;strong&gt;Object&lt;/strong&gt; class&amp;rsquo;ının &lt;strong&gt;create&lt;/strong&gt; methodu kullanılarak:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var o = Object.create({n:1, b:true});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Object.create method&amp;rsquo;unun asıl kullanımı şu şekilde ancak bu yazı sonuna kalsın: &lt;strong&gt;Object.create(prototype &lt;em&gt;[, properties]&lt;/em&gt;)&lt;/strong&gt;
hızlıca bu tanım doğrultusunda doğru bir kullanım aslında şu şekilde olmalıydı:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var o = Object.create(Object.prototype, {n:{value:1}, b:{value:true}});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Son object oluşturma yöntemi ise &lt;strong&gt;constructor function&lt;/strong&gt; tanımlayıp instance edinerek:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function anO(n){
  this.s = &amp;quot;value&amp;quot;;
  this.n = n; 
}

var o = new anO(1);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_1&#34;&gt;prototype&lt;/h2&gt;

&lt;p&gt;javascript&amp;rsquo;te object-oriented programming dökümanlarına baktığınız zaman &lt;strong&gt;prototype&lt;/strong&gt; kavramı ile karşılaşmanız kaçınılmazdır. prototype, oluşturduğunuz instance&amp;rsquo;ların miras alacağı property&amp;rsquo;leri barındıran bir object. &lt;code&gt;new&lt;/code&gt; &lt;strong&gt;keyword&lt;/strong&gt;&amp;lsquo;ü kullanarak oluşturduğunuz instance, &lt;strong&gt;class&amp;rsquo;ının prototype object&amp;rsquo;indeki tanımlı property&amp;rsquo;leri miras alarak&lt;/strong&gt; oluşturulur. basit bir örnek vermek gerekirse &lt;code&gt;var a = new Array(1,2,3);&lt;/code&gt; şeklinde oluşturduğunuz bir &lt;code&gt;a&lt;/code&gt; değişkeni, &lt;strong&gt;Array.prototype&lt;/strong&gt; object&amp;rsquo;inden &lt;strong&gt;push&lt;/strong&gt; methodunu miras alır.&lt;/p&gt;

&lt;p&gt;az önceki &lt;strong&gt;Object.create&lt;/strong&gt; method&amp;rsquo;unun kullanımını şimdi fark etmiş olmalısınız, &lt;strong&gt;ilk parametre miras alınacak prototype, ikinci parametre ise instance&amp;rsquo;ın kendi property&amp;rsquo;leri&lt;/strong&gt; şeklinde. biz ilk kullanımda aslında kendisine &lt;code&gt;{n:1, b:true}&lt;/code&gt; şeklinde tanımlı bir &lt;strong&gt;prototype&lt;/strong&gt; vermiştik ve &lt;code&gt;o&lt;/code&gt; değişkeni bu prototype&amp;rsquo;dan property&amp;rsquo;leri miras almıştı.&lt;/p&gt;

&lt;p&gt;anlaşıldığı gibi, class-based dillere nazaran prototype-based bir dil olan javascript&amp;rsquo;te bir class tanımlamak istediğinizde instance tarafından miras alınacak property&amp;rsquo;leri prototype&amp;rsquo;ına tanımlayacaksınız. bir örnek:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function Ornek(a,b){
  this.a = a || 0;
  this.b = b || 0;
}

Ornek.prototype.topla = function(){ return this.a+this.b; };

var o = new Ornek(1,2);
console.log( o.topla() );
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_2&#34;&gt;property&lt;/h2&gt;

&lt;p&gt;property&amp;rsquo;ler object&amp;rsquo;lerde key-value olarak taşınan değerler demiştik. bu genel başlık altında property&amp;rsquo;lerin türleri ve özelliklerini inceleyeceğiz.&lt;/p&gt;

&lt;p&gt;ilk olarak javascript object&amp;rsquo;lerinde &lt;strong&gt;&amp;ldquo;öz nitelik&amp;rdquo; (own-property)&lt;/strong&gt; kavramına değinelim. adında da anlaşılabileceği gibi, miras alınan property&amp;rsquo;ler ile initial değer alarak tanımlanmış property&amp;rsquo;leri iki ayrı sınıfa ayırabiliriz. object içerisinde tanımlanmış property&amp;rsquo;ler, &amp;ldquo;öz nitelik&amp;rdquo; sınıfına dahil olacaktır. yukarıdaki &lt;code&gt;Ornek&lt;/code&gt; constructor function&amp;rsquo;ında tanımlanmış olan &lt;code&gt;a&lt;/code&gt; ve &lt;code&gt;b&lt;/code&gt; nitelikleri &lt;code&gt;Ornek&lt;/code&gt; class&amp;rsquo;ından edinilmiş bir instance&amp;rsquo;ın öz niteliği olup, miras alınan property&amp;rsquo;ler ise ( prototype&amp;rsquo;dan gelen property&amp;rsquo;ler ) öz nitelik sınıfına dahil değildir. javascript&amp;rsquo;te bunu sorgulamak için &lt;strong&gt;hasOwnProperty&lt;/strong&gt; methodu kullanılabilir &lt;em&gt;(Object class&amp;rsquo;ının prototype&amp;rsquo;ından miras alınan bir method)&lt;/em&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;o.hasOwnProperty(&#39;a&#39;); // true
o.hasOwnProperty(&#39;topla&#39;); // false
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;tüm own property listesini edinmek içinse: &lt;strong&gt;Object.getOwnPropertyNames(obj)&lt;/strong&gt;, örnek: &lt;code&gt;Object.getOwnPropertyNames(o);&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;belki dikkatinizi çekmiştir, &lt;code&gt;o.hasOwnProperty&lt;/code&gt; methodunu object&amp;rsquo;den miras alıyoruz ancak &lt;code&gt;getOwnPropertyNames&lt;/code&gt; miras alınmıyor. Sebebi: getOwnPropertyNames methodu Object class&amp;rsquo;ının own property&amp;rsquo;sidir.&lt;/p&gt;

&lt;h3 id=&#34;toc_3&#34;&gt;accessor property&lt;/h3&gt;

&lt;p&gt;accessor property türündeki fark, bir property için getter/setter methodları belirleyebilmenizi sağlar. kolay bir kullanımı var, yerine göre de çok kullanışlı olacaktır.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var o = {
  n: 1,
  get a(){ return this.n; },
  set a(v){ this.n = v*v; }
};

o.a // 1
o.a = 4; 
o.a // 16
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;gördüğünüz gibi accessor property&amp;rsquo;ler &lt;strong&gt;fonksiyon-vari&lt;/strong&gt; bir syntax kullanılarak tanımlanıyor. getter fonksiyonu için &amp;ldquo;get&amp;rdquo;, setter içinse &amp;ldquo;set&amp;rdquo; keyword&amp;rsquo;ünü kullanarak fonksiyonlarınızı tanımlıyorsunuz ve fonksiyon ismi property&amp;rsquo;niz oluyor.&lt;/p&gt;

&lt;h3 id=&#34;toc_4&#34;&gt;property descriptor&lt;/h3&gt;

&lt;p&gt;genel olarak property&amp;rsquo;lerin ismi ve değeri dışında taşığı belirli özellikleri vardır. bunlar &lt;strong&gt;normal property&amp;rsquo;ler (data-property)&lt;/strong&gt; için &lt;em&gt;value,writable,enumerable ve configurable&lt;/em&gt; iken &lt;strong&gt;accessor property&amp;rsquo;ler&lt;/strong&gt; için &lt;em&gt;get,set,enumerable ve configurable&lt;/em&gt; şeklindedir. bu attribute&amp;rsquo;ları property olarak taşıyan object veri property-descriptor olarak tanımlanır.&lt;/p&gt;

&lt;h4 id=&#34;toc_5&#34;&gt;data-property&amp;rsquo;lerin attribute&amp;rsquo;ları&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;value&lt;/strong&gt;: property&amp;rsquo;nin taşıdığı değerdir, herhangi bir javascript değeri olabilir. (number,string,function,object,null,&amp;hellip;)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;writable&lt;/strong&gt;: property&amp;rsquo;nin yazılabilir olduğunu işaret eden attribute.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;enumerable&lt;/strong&gt;: property&amp;rsquo;nin &lt;em&gt;sayılabilir&lt;/em&gt; yani in/of döngülerinde listelenebilir olduğunu işaret eden attribute.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;configurable&lt;/strong&gt;: property&amp;rsquo;nin üzerine yazılabilir/silinebilir olduğunu işaret eden attribute.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;toc_6&#34;&gt;accessor-property&amp;rsquo;lerin attribute&amp;rsquo;ları&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;get&lt;/strong&gt;: property&amp;rsquo;nin getter fonksiyonu&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;set&lt;/strong&gt;: property&amp;rsquo;nin setter fonksiyonu, undefined olması durumunda property&amp;rsquo;nin yazılamaz olduğunu bildirir.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;enumerable&lt;/strong&gt;: data-property&amp;rsquo;deki gibi&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;configurable&lt;/strong&gt;: data-property&amp;rsquo;deki gibi&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;bir object&amp;rsquo;in descriptor&amp;rsquo;unu edinmek için &lt;strong&gt;Object.getOwnPropertyDescriptor(obj, prop)&lt;/strong&gt; kullanılabilir. method&amp;rsquo;un adından da anlaşılabileceği gibi &lt;strong&gt;own-property&amp;rsquo;lerin descriptor&amp;rsquo;ları edinilir&lt;/strong&gt;, miras alınan property&amp;rsquo;ler için false değeri dönecektir.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function Ornek(a,b){
  this.a = a || 0;
  this.b = b || 0;
}

Ornek.prototype.topla = function(){ return this.a+this.b; };

var o = new Ornek(1,2);

Object.getOwnPropertyDescriptor(o, &#39;topla&#39;); 
// false

Object.getOwnPropertyDescriptor(o, &#39;a&#39;);
// { value:1, writable:true, enumerable:true, configurable:true }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;descriptor tanımla işlemi ise &lt;strong&gt;Object.defineProperty(obj, prop, desc)&lt;/strong&gt; ile yapılır. burda bilmeniz gereken defineProperty ile yapılan descriptor&amp;rsquo;larda tanımlanmamış attribute&amp;rsquo;ler &lt;strong&gt;false&lt;/strong&gt; değerini alır.&lt;/p&gt;

&lt;p&gt;attribute ve accessor-property&amp;rsquo;ler için örnekler verelim. prototype üzerinden tanımlayalım, bu da object&amp;rsquo;lerin referanslarla işlendiğini görmenize yardımcı olsun.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;writable&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;Object.defineProperty(Ornek.prototype, &#39;origin&#39;, {
  value:0,
  writable:false,
  enumerable:true,
  configurable:true
});

o.origin; // 0
o.origin = 5; // hata vermez ancak çalışmaz. strict mode&#39;da hata verir.
o.origin; // 0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;writable değeri false olan bir property&amp;rsquo;ye gördüğünüz gibi yeni bir değer atanamaz. ayrıca bu örnekte gördüğünüz gibi o instance&amp;rsquo;ı &lt;em&gt;origin&lt;/em&gt; property&amp;rsquo;si eklenmeden önce instance edilmiş olsa da, &lt;strong&gt;object&amp;rsquo;lerin referance ile işlenmesinden dolayı&lt;/strong&gt; yeni property &lt;em&gt;origin&lt;/em&gt;&amp;lsquo;i de miras aldı.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;configurable&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;origin property&amp;rsquo;si read-only&amp;rsquo;dir, kendisine yeni bir değer atanamaz ancak hala configurable olduğundan descriptor&amp;rsquo;un üzerine yazılabilir.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;Object.defineProperty(Ornek.prototype, &#39;origin&#39;, {
  value:2,
});

o.origin; // 2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;burda yeni descriptor yazılarak tanımlanan &lt;em&gt;origin&lt;/em&gt; property&amp;rsquo;si tanımlanmamış attribute&amp;rsquo;ları önceki descriptor&amp;rsquo;dan &lt;strong&gt;miras&lt;/strong&gt; alır. yeni descriptor&amp;rsquo;da configurable false yapılsaydı, &lt;code&gt;delete o.origin&lt;/code&gt; false değerini dönecekti ve yeni bir descriptor ile origin&amp;rsquo;i tekrar tanımla işlemi &lt;strong&gt;hata&lt;/strong&gt; verecekti.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;enumerable&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;origin property&amp;rsquo;sinin attribute&amp;rsquo;ları üzerine yazarak devam edelim.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;Object.keys(Ornek.prototype); // listede origin de var

Object.defineProperty(Ornek.prototype, &#39;origin&#39;, {enumerable:false});

Object.keys(Ornek.prototype); // listede origin yok

// ya da

Ornek.prototype.propertyIsEnumerable(&#39;origin&#39;); // false
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;accessor property&amp;rsquo;ler içinse tanımla işlemi şu şekildedir:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;Object.defineProperty(Ornek.prototype, &#39;d&#39;, {
  get: function(){ return Math.sqrt(this.a*this.a + this.b*this.b); },
  configurable: false
});

o.d;
delete o.d; // false
Object.defineProperty(Ornek.prototype, &#39;d&#39;, {...}); // throw TypeError: Cannot redefine
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_7&#34;&gt;object attributes&lt;/h2&gt;

&lt;p&gt;javascript&amp;rsquo;te her object &lt;strong&gt;prototype&lt;/strong&gt;, &lt;strong&gt;class&lt;/strong&gt; ve &lt;strong&gt;extensible&lt;/strong&gt; attribute&amp;rsquo;larını taşır.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;prototype&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;daha önce de bahsettiğimiz gibi miras alınacak property&amp;rsquo;leri taşıyan object datadır. &amp;ldquo;.isPrototypeOf&amp;rdquo; methodu yardımıyla sorgulanabilir:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;Ornek.prototype.isPrototypeOf(o); // true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;instance tarafında prototype erişmemizi sağlayan &lt;strong&gt;&lt;strong&gt;proto&lt;/strong&gt;&lt;/strong&gt; accessor-property&amp;rsquo;si mevcuttur: &lt;code&gt;o.__proto__ === Ornek.prototype&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;class&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;object type&amp;rsquo;ı hakkında bilgi veren string değerdir. toString çağrısıyla elde edilen string değerin ikinci kısmıdır.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;extensible&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;object&amp;rsquo;e yeni bir property eklenip eklenemeyeceğini belirten değerdir. bir object&amp;rsquo;in extensible olup olmadığını sorgulamak için:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;Object.isExtensible(Ornek.prototype); // true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;bir object&amp;rsquo;i nonextensible yapmak için ise &lt;strong&gt;Object.preventExtensions(obj)&lt;/strong&gt; kullanılabilir:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;Object.preventExtensions(o); // o object&#39;ini ( Ornek instance&#39;ı ) nonextensible yaptık.
o.xyz = 1; // gecersiz olur.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;burda instance üzerinden örnek vermemin sebebi, preventExtensions &lt;strong&gt;own-property&lt;/strong&gt;&amp;lsquo;ler için geçerlidir. yani Ornek.prototype&amp;rsquo;a bir property eklediğiniz zaman bu yine miras alınır. ayrıca nonextensible yapılan bir object tekrar extensible yapılamaz.&lt;/p&gt;

&lt;p&gt;preventExtensions benzeri fonksiyonlar da mevcut: &lt;strong&gt;Object.seal(obj)&lt;/strong&gt; ve &lt;strong&gt;Object.freeze(obj)&lt;/strong&gt;, benzer şekilde object&amp;rsquo;lerin sealed ya da frozen durumları sırasıyla &lt;strong&gt;Object.isSealed(obj)&lt;/strong&gt; ve &lt;strong&gt;Object.isFrozen(obj)&lt;/strong&gt; fonksiyonları aracılığıyla sorgulanabilir.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Object.seal(o);&lt;/code&gt; ile o object&amp;rsquo;i nonextensible yaptığı gibi, object&amp;rsquo;in own-property&amp;rsquo;lerini de nonconfigurable yapar. &lt;code&gt;Object.freeze(o);&lt;/code&gt; ise seal&amp;rsquo;e artı olarak bütün own-property&amp;rsquo;leri read-only yapar.&lt;/p&gt;

&lt;p&gt;bitirirken; javascript&amp;rsquo;te oop uzun uzadıya bir yazı olabileceği için kendisinden fazla bahsedemedim ancak property&amp;rsquo;leri etkin bir şekilde kullanabileceğinizi umuyorum. oop konusu da diğer yazılara kalsın artık :)&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>